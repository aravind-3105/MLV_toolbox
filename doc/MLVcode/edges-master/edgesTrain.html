<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of edgesTrain</title>
  <meta name="keywords" content="edgesTrain">
  <meta name="description" content="Train structured edge detector.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">MLVcode</a> &gt; <a href="index.html">edges-master</a> &gt; edgesTrain.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>edgesTrain
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Train structured edge detector.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function model = edgesTrain( varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Train structured edge detector.

 For an introductory tutorial please see edgesDemo.m.

 USAGE
  opts = edgesTrain()
  model = edgesTrain( opts )

 INPUTS
  opts       - parameters (struct or name/value pairs)
   (1) model parameters:
   .imWidth    - [32] width of image patches
   .gtWidth    - [16] width of ground truth patches
   (2) tree parameters:
   .nPos       - [5e5] number of positive patches per tree
   .nNeg       - [5e5] number of negative patches per tree
   .nImgs      - [inf] maximum number of images to use for training
   .nTrees     - [8] number of trees in forest to train
   .fracFtrs   - [1/4] fraction of features to use to train each tree
   .minCount   - [1] minimum number of data points to allow split
   .minChild   - [8] minimum number of data points allowed at child nodes
   .maxDepth   - [64] maximum depth of tree
   .discretize - ['pca'] options include 'pca' and 'kmeans'
   .nSamples   - [256] number of samples for clustering structured labels
   .nClasses   - [2] number of classes (clusters) for binary splits
   .split      - ['gini'] options include 'gini', 'entropy' and 'twoing'
   (3) feature parameters:
   .nOrients   - [4] number of orientations per gradient scale
   .grdSmooth  - [0] radius for image gradient smoothing (using convTri)
   .chnSmooth  - [2] radius for reg channel smoothing (using convTri)
   .simSmooth  - [8] radius for sim channel smoothing (using convTri)
   .normRad    - [4] gradient normalization radius (see gradientMag)
   .shrink     - [2] amount to shrink channels
   .nCells     - [5] number of self similarity cells
   .rgbd       - [0] 0:RGB, 1:depth, 2:RBG+depth (for NYU data only)
   (4) detection parameters (can be altered after training):
   .stride     - [2] stride at which to compute edges
   .multiscale - [0] if true run multiscale edge detector
   .sharpen    - [2] sharpening amount (can only decrease after training)
   .nTreesEval - [4] number of trees to evaluate per location
   .nThreads   - [4] number of threads for evaluation of trees
   .nms        - [0] if true apply non-maximum suppression to edges
   (5) other parameters:
   .seed       - [1] seed for random stream (for reproducibility)
   .useParfor  - [0] if true train trees in parallel (memory intensive)
   .modelDir   - ['models/'] target directory for storing models
   .modelFnm   - ['model'] model filename
   .bsdsDir    - ['BSR/BSDS500/data/'] location of BSDS dataset

 OUTPUTS
  model      - trained structured edge detector w the following fields
   .opts       - input parameters and constants
   .thrs       - [nNodes x nTrees] threshold corresponding to each fid
   .fids       - [nNodes x nTrees] feature ids for each node
   .child      - [nNodes x nTrees] index of child for each node
   .count      - [nNodes x nTrees] number of data points at each node
   .depth      - [nNodes x nTrees] depth of each node
   .eBins      - data structure for storing all node edge maps
   .eBnds      - data structure for storing all node edge maps

 EXAMPLE

 See also <a href="edgesDemo.html" class="code" title="">edgesDemo</a>, <a href="edgesChns.html" class="code" title="function [chnsReg,chnsSim] = edgesChns( I, opts )">edgesChns</a>, <a href="edgesDetect.html" class="code" title="function [E,O,inds,segs] = edgesDetect( I, model )">edgesDetect</a>, forestTrain

 Structured Edge Detection Toolbox      Version 3.01
 Code written by Piotr Dollar, 2014.
 Licensed under the MSR-LA Full Rights License [see license.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="edgesChns.html" class="code" title="function [chnsReg,chnsSim] = edgesChns( I, opts )">edgesChns</a>	Compute features for structured edge detection.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="edgesDemo.html" class="code" title="">edgesDemo</a>	Demo for Structured Edge Detector (please see readme.txt first).</li><li><a href="edgesDemoRgbd.html" class="code" title="">edgesDemoRgbd</a>	Demo for RGBD Structured Edge Detector (please see readme.txt first).</li><li><a href="edgesSweeps.html" class="code" title="function edgesSweeps()">edgesSweeps</a>	Parameter sweeps for structured edge detector.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function model = mergeTrees( opts )</a></li><li><a href="#_sub2" class="code">function trainTree( opts, stream, treeInd )</a></li><li><a href="#_sub3" class="code">function ftrs = stComputeSimFtrs( chns, opts )</a></li><li><a href="#_sub4" class="code">function [hs,segs] = discretize( segs, nClasses, nSamples, type )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function model = edgesTrain( varargin )</a>
0002 <span class="comment">% Train structured edge detector.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% For an introductory tutorial please see edgesDemo.m.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% USAGE</span>
0007 <span class="comment">%  opts = edgesTrain()</span>
0008 <span class="comment">%  model = edgesTrain( opts )</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% INPUTS</span>
0011 <span class="comment">%  opts       - parameters (struct or name/value pairs)</span>
0012 <span class="comment">%   (1) model parameters:</span>
0013 <span class="comment">%   .imWidth    - [32] width of image patches</span>
0014 <span class="comment">%   .gtWidth    - [16] width of ground truth patches</span>
0015 <span class="comment">%   (2) tree parameters:</span>
0016 <span class="comment">%   .nPos       - [5e5] number of positive patches per tree</span>
0017 <span class="comment">%   .nNeg       - [5e5] number of negative patches per tree</span>
0018 <span class="comment">%   .nImgs      - [inf] maximum number of images to use for training</span>
0019 <span class="comment">%   .nTrees     - [8] number of trees in forest to train</span>
0020 <span class="comment">%   .fracFtrs   - [1/4] fraction of features to use to train each tree</span>
0021 <span class="comment">%   .minCount   - [1] minimum number of data points to allow split</span>
0022 <span class="comment">%   .minChild   - [8] minimum number of data points allowed at child nodes</span>
0023 <span class="comment">%   .maxDepth   - [64] maximum depth of tree</span>
0024 <span class="comment">%   .discretize - ['pca'] options include 'pca' and 'kmeans'</span>
0025 <span class="comment">%   .nSamples   - [256] number of samples for clustering structured labels</span>
0026 <span class="comment">%   .nClasses   - [2] number of classes (clusters) for binary splits</span>
0027 <span class="comment">%   .split      - ['gini'] options include 'gini', 'entropy' and 'twoing'</span>
0028 <span class="comment">%   (3) feature parameters:</span>
0029 <span class="comment">%   .nOrients   - [4] number of orientations per gradient scale</span>
0030 <span class="comment">%   .grdSmooth  - [0] radius for image gradient smoothing (using convTri)</span>
0031 <span class="comment">%   .chnSmooth  - [2] radius for reg channel smoothing (using convTri)</span>
0032 <span class="comment">%   .simSmooth  - [8] radius for sim channel smoothing (using convTri)</span>
0033 <span class="comment">%   .normRad    - [4] gradient normalization radius (see gradientMag)</span>
0034 <span class="comment">%   .shrink     - [2] amount to shrink channels</span>
0035 <span class="comment">%   .nCells     - [5] number of self similarity cells</span>
0036 <span class="comment">%   .rgbd       - [0] 0:RGB, 1:depth, 2:RBG+depth (for NYU data only)</span>
0037 <span class="comment">%   (4) detection parameters (can be altered after training):</span>
0038 <span class="comment">%   .stride     - [2] stride at which to compute edges</span>
0039 <span class="comment">%   .multiscale - [0] if true run multiscale edge detector</span>
0040 <span class="comment">%   .sharpen    - [2] sharpening amount (can only decrease after training)</span>
0041 <span class="comment">%   .nTreesEval - [4] number of trees to evaluate per location</span>
0042 <span class="comment">%   .nThreads   - [4] number of threads for evaluation of trees</span>
0043 <span class="comment">%   .nms        - [0] if true apply non-maximum suppression to edges</span>
0044 <span class="comment">%   (5) other parameters:</span>
0045 <span class="comment">%   .seed       - [1] seed for random stream (for reproducibility)</span>
0046 <span class="comment">%   .useParfor  - [0] if true train trees in parallel (memory intensive)</span>
0047 <span class="comment">%   .modelDir   - ['models/'] target directory for storing models</span>
0048 <span class="comment">%   .modelFnm   - ['model'] model filename</span>
0049 <span class="comment">%   .bsdsDir    - ['BSR/BSDS500/data/'] location of BSDS dataset</span>
0050 <span class="comment">%</span>
0051 <span class="comment">% OUTPUTS</span>
0052 <span class="comment">%  model      - trained structured edge detector w the following fields</span>
0053 <span class="comment">%   .opts       - input parameters and constants</span>
0054 <span class="comment">%   .thrs       - [nNodes x nTrees] threshold corresponding to each fid</span>
0055 <span class="comment">%   .fids       - [nNodes x nTrees] feature ids for each node</span>
0056 <span class="comment">%   .child      - [nNodes x nTrees] index of child for each node</span>
0057 <span class="comment">%   .count      - [nNodes x nTrees] number of data points at each node</span>
0058 <span class="comment">%   .depth      - [nNodes x nTrees] depth of each node</span>
0059 <span class="comment">%   .eBins      - data structure for storing all node edge maps</span>
0060 <span class="comment">%   .eBnds      - data structure for storing all node edge maps</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% EXAMPLE</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% See also edgesDemo, edgesChns, edgesDetect, forestTrain</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% Structured Edge Detection Toolbox      Version 3.01</span>
0067 <span class="comment">% Code written by Piotr Dollar, 2014.</span>
0068 <span class="comment">% Licensed under the MSR-LA Full Rights License [see license.txt]</span>
0069 
0070 <span class="comment">% get default parameters</span>
0071 dfs={<span class="string">'imWidth'</span>,32, <span class="string">'gtWidth'</span>,16, <span class="string">'nPos'</span>,5e5, <span class="string">'nNeg'</span>,5e5, <span class="string">'nImgs'</span>,inf, <span class="keyword">...</span>
0072   <span class="string">'nTrees'</span>,8, <span class="string">'fracFtrs'</span>,1/4, <span class="string">'minCount'</span>,1, <span class="string">'minChild'</span>,8, <span class="keyword">...</span>
0073   <span class="string">'maxDepth'</span>,64, <span class="string">'discretize'</span>,<span class="string">'pca'</span>, <span class="string">'nSamples'</span>,256, <span class="string">'nClasses'</span>,2, <span class="keyword">...</span>
0074   <span class="string">'split'</span>,<span class="string">'gini'</span>, <span class="string">'nOrients'</span>,4, <span class="string">'grdSmooth'</span>,0, <span class="string">'chnSmooth'</span>,2, <span class="keyword">...</span>
0075   <span class="string">'simSmooth'</span>,8, <span class="string">'normRad'</span>,4, <span class="string">'shrink'</span>,2, <span class="string">'nCells'</span>,5, <span class="string">'rgbd'</span>,0, <span class="keyword">...</span>
0076   <span class="string">'stride'</span>,2, <span class="string">'multiscale'</span>,0, <span class="string">'sharpen'</span>,2, <span class="string">'nTreesEval'</span>,4, <span class="keyword">...</span>
0077   <span class="string">'nThreads'</span>,4, <span class="string">'nms'</span>,0, <span class="string">'seed'</span>,1, <span class="string">'useParfor'</span>,0, <span class="string">'modelDir'</span>,<span class="string">'models/'</span>, <span class="keyword">...</span>
0078   <span class="string">'modelFnm'</span>,<span class="string">'model'</span>, <span class="string">'bsdsDir'</span>,<span class="string">'BSR/BSDS500/data/'</span>};
0079 opts = getPrmDflt(varargin,dfs,1);
0080 <span class="keyword">if</span>(nargin==0), model=opts; <span class="keyword">return</span>; <span class="keyword">end</span>
0081 
0082 <span class="comment">% if forest exists load it and return</span>
0083 cd(fileparts(mfilename(<span class="string">'fullpath'</span>)));
0084 forestDir = [opts.modelDir <span class="string">'/forest/'</span>];
0085 forestFn = [forestDir opts.modelFnm];
0086 <span class="keyword">if</span>(exist([forestFn <span class="string">'.mat'</span>], <span class="string">'file'</span>))
0087   load([forestFn <span class="string">'.mat'</span>]); <span class="keyword">return</span>; <span class="keyword">end</span>
0088 
0089 <span class="comment">% compute constants and store in opts</span>
0090 nTrees=opts.nTrees; nCells=opts.nCells; shrink=opts.shrink;
0091 opts.nPos=round(opts.nPos); opts.nNeg=round(opts.nNeg);
0092 opts.nTreesEval=min(opts.nTreesEval,nTrees);
0093 opts.stride=max(opts.stride,shrink);
0094 imWidth=opts.imWidth; gtWidth=opts.gtWidth;
0095 imWidth=round(max(gtWidth,imWidth)/shrink/2)*shrink*2;
0096 opts.imWidth=imWidth; opts.gtWidth=gtWidth;
0097 nChnsGrad=(opts.nOrients+1)*2; nChnsColor=3;
0098 <span class="keyword">if</span>(opts.rgbd==1), nChnsColor=1; <span class="keyword">end</span>
0099 <span class="keyword">if</span>(opts.rgbd==2), nChnsGrad=nChnsGrad*2; nChnsColor=nChnsColor+1; <span class="keyword">end</span>
0100 nChns = nChnsGrad+nChnsColor; opts.nChns = nChns;
0101 opts.nChnFtrs = imWidth*imWidth*nChns/shrink/shrink;
0102 opts.nSimFtrs = (nCells*nCells)*(nCells*nCells-1)/2*nChns;
0103 opts.nTotFtrs = opts.nChnFtrs + opts.nSimFtrs; disp(opts);
0104 
0105 <span class="comment">% generate stream for reproducibility of model</span>
0106 stream=RandStream(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,opts.seed);
0107 
0108 <span class="comment">% train nTrees random trees (can be trained with parfor if enough memory)</span>
0109 <span class="keyword">if</span>(opts.useParfor), parfor i=1:nTrees, <a href="#_sub2" class="code" title="subfunction trainTree( opts, stream, treeInd )">trainTree</a>(opts,stream,i); <span class="keyword">end</span>
0110 <span class="keyword">else</span> <span class="keyword">for</span> i=1:nTrees, <a href="#_sub2" class="code" title="subfunction trainTree( opts, stream, treeInd )">trainTree</a>(opts,stream,i); <span class="keyword">end</span>; <span class="keyword">end</span>
0111 
0112 <span class="comment">% merge trees and save model</span>
0113 model = <a href="#_sub1" class="code" title="subfunction model = mergeTrees( opts )">mergeTrees</a>( opts );
0114 <span class="keyword">if</span>(~exist(forestDir,<span class="string">'dir'</span>)), mkdir(forestDir); <span class="keyword">end</span>
0115 save([forestFn <span class="string">'.mat'</span>], <span class="string">'model'</span>, <span class="string">'-v7.3'</span>);
0116 
0117 <span class="keyword">end</span>
0118 
0119 <a name="_sub1" href="#_subfunctions" class="code">function model = mergeTrees( opts )</a>
0120 <span class="comment">% accumulate trees and merge into final model</span>
0121 nTrees=opts.nTrees; gtWidth=opts.gtWidth;
0122 treeFn = [opts.modelDir <span class="string">'/tree/'</span> opts.modelFnm <span class="string">'_tree'</span>];
0123 <span class="keyword">for</span> i=1:nTrees
0124   t=load([treeFn int2str2(i,3) <span class="string">'.mat'</span>],<span class="string">'tree'</span>); t=t.tree;
0125   <span class="keyword">if</span>(i==1), trees=t(ones(1,nTrees)); <span class="keyword">else</span> trees(i)=t; <span class="keyword">end</span>
0126 <span class="keyword">end</span>
0127 nNodes=0; <span class="keyword">for</span> i=1:nTrees, nNodes=max(nNodes,size(trees(i).fids,1)); <span class="keyword">end</span>
0128 <span class="comment">% merge all fields of all trees</span>
0129 model.opts=opts; Z=zeros(nNodes,nTrees,<span class="string">'uint32'</span>);
0130 model.thrs=zeros(nNodes,nTrees,<span class="string">'single'</span>);
0131 model.fids=Z; model.child=Z; model.count=Z; model.depth=Z;
0132 model.segs=zeros(gtWidth,gtWidth,nNodes,nTrees,<span class="string">'uint8'</span>);
0133 <span class="keyword">for</span> i=1:nTrees, tree=trees(i); nNodes1=size(tree.fids,1);
0134   model.fids(1:nNodes1,i) = tree.fids;
0135   model.thrs(1:nNodes1,i) = tree.thrs;
0136   model.child(1:nNodes1,i) = tree.child;
0137   model.count(1:nNodes1,i) = tree.count;
0138   model.depth(1:nNodes1,i) = tree.depth;
0139   model.segs(:,:,1:nNodes1,i) = tree.hs-1;
0140 <span class="keyword">end</span>
0141 <span class="comment">% remove very small segments (&lt;=5 pixels)</span>
0142 segs=model.segs; nSegs=squeeze(max(max(segs)))+1;
0143 parfor i=1:nTrees*nNodes, m=nSegs(i);
0144   <span class="keyword">if</span>(m==1), <span class="keyword">continue</span>; <span class="keyword">end</span>; S=segs(:,:,i); del=0;
0145   <span class="keyword">for</span> j=1:m, Sj=(S==j-1); <span class="keyword">if</span>(nnz(Sj)&gt;5), <span class="keyword">continue</span>; <span class="keyword">end</span>
0146     S(Sj)=median(single(S(convTri(single(Sj),1)&gt;0))); del=1; <span class="keyword">end</span>
0147   <span class="keyword">if</span>(del), [~,~,S]=unique(S); S=reshape(S-1,gtWidth,gtWidth);
0148     segs(:,:,i)=S; nSegs(i)=max(S(:))+1; <span class="keyword">end</span>
0149 <span class="keyword">end</span>
0150 model.segs=segs; model.nSegs=nSegs;
0151 <span class="comment">% store compact representations of sparse binary edge patches</span>
0152 nBnds=opts.sharpen+1; eBins=cell(nTrees*nNodes,nBnds);
0153 eBnds=zeros(nNodes*nTrees,nBnds);
0154 parfor i=1:nTrees*nNodes
0155   <span class="keyword">if</span>(model.child(i) || model.nSegs(i)==1), <span class="keyword">continue</span>; <span class="keyword">end</span> <span class="comment">%#ok&lt;PFBNS&gt;</span>
0156   E=gradientMag(single(model.segs(:,:,i)))&gt;.01; E0=0;
0157   <span class="keyword">for</span> j=1:nBnds, eBins{i,j}=uint16(find(E &amp; ~E0)'-1); E0=E;
0158     eBnds(i,j)=length(eBins{i,j}); E=convTri(single(E),1)&gt;.01; <span class="keyword">end</span>
0159 <span class="keyword">end</span>
0160 eBins=eBins'; model.eBins=[eBins{:}]';
0161 eBnds=eBnds'; model.eBnds=uint32([0; cumsum(eBnds(:))]);
0162 <span class="keyword">end</span>
0163 
0164 <a name="_sub2" href="#_subfunctions" class="code">function trainTree( opts, stream, treeInd )</a>
0165 <span class="comment">% Train a single tree in forest model.</span>
0166 
0167 <span class="comment">% location of ground truth</span>
0168 trnImgDir = [opts.bsdsDir <span class="string">'/images/train/'</span>];
0169 trnDepDir = [opts.bsdsDir <span class="string">'/depth/train/'</span>];
0170 trnGtDir = [opts.bsdsDir <span class="string">'/groundTruth/train/'</span>];
0171 imgIds=dir(trnImgDir); imgIds=imgIds([imgIds.bytes]&gt;0);
0172 imgIds={imgIds.name}; ext=imgIds{1}(end-2:end);
0173 nImgs=length(imgIds); <span class="keyword">for</span> i=1:nImgs, imgIds{i}=imgIds{i}(1:end-4); <span class="keyword">end</span>
0174 
0175 <span class="comment">% extract commonly used options</span>
0176 imWidth=opts.imWidth; imRadius=imWidth/2;
0177 gtWidth=opts.gtWidth; gtRadius=gtWidth/2;
0178 nChns=opts.nChns; nTotFtrs=opts.nTotFtrs; rgbd=opts.rgbd;
0179 nPos=opts.nPos; nNeg=opts.nNeg; shrink=opts.shrink;
0180 
0181 <span class="comment">% finalize setup</span>
0182 treeDir = [opts.modelDir <span class="string">'/tree/'</span>];
0183 treeFn = [treeDir opts.modelFnm <span class="string">'_tree'</span>];
0184 <span class="keyword">if</span>(exist([treeFn int2str2(treeInd,3) <span class="string">'.mat'</span>],<span class="string">'file'</span>))
0185   fprintf(<span class="string">'Reusing tree %d of %d\n'</span>,treeInd,opts.nTrees); <span class="keyword">return</span>; <span class="keyword">end</span>
0186 fprintf(<span class="string">'\n-------------------------------------------\n'</span>);
0187 fprintf(<span class="string">'Training tree %d of %d\n'</span>,treeInd,opts.nTrees); tStart=clock;
0188 
0189 <span class="comment">% set global stream to stream with given substream (will undo at end)</span>
0190 streamOrig = RandStream.getGlobalStream();
0191 set(stream,<span class="string">'Substream'</span>,treeInd);
0192 RandStream.setGlobalStream( stream );
0193 
0194 <span class="comment">% collect positive and negative patches and compute features</span>
0195 fids=sort(randperm(nTotFtrs,round(nTotFtrs*opts.fracFtrs)));
0196 k = nPos+nNeg; nImgs=min(nImgs,opts.nImgs);
0197 ftrs = zeros(k,length(fids),<span class="string">'single'</span>);
0198 labels = zeros(gtWidth,gtWidth,k,<span class="string">'uint8'</span>); k = 0;
0199 tid = ticStatus(<span class="string">'Collecting data'</span>,30,1);
0200 <span class="keyword">for</span> i = 1:nImgs
0201   <span class="comment">% get image and compute channels</span>
0202   gt=load([trnGtDir imgIds{i} <span class="string">'.mat'</span>]); gt=gt.groundTruth;
0203   I=imread([trnImgDir imgIds{i} <span class="string">'.'</span> ext]); siz=size(I);
0204   <span class="keyword">if</span>(rgbd), D=single(imread([trnDepDir imgIds{i} <span class="string">'.png'</span>]))/1e4; <span class="keyword">end</span>
0205   <span class="keyword">if</span>(rgbd==1), I=D; <span class="keyword">elseif</span>(rgbd==2), I=cat(3,single(I)/255,D); <span class="keyword">end</span>
0206   p=zeros(1,4); p([2 4])=mod(4-mod(siz(1:2),4),4);
0207   <span class="keyword">if</span>(any(p)), I=imPad(I,p,<span class="string">'symmetric'</span>); <span class="keyword">end</span>
0208   [chnsReg,chnsSim] = <a href="edgesChns.html" class="code" title="function [chnsReg,chnsSim] = edgesChns( I, opts )">edgesChns</a>(I,opts);
0209   <span class="comment">% sample positive and negative locations</span>
0210   nGt=length(gt); xy=[]; k1=0; B=false(siz(1),siz(2));
0211   B(shrink:shrink:<span class="keyword">end</span>,shrink:shrink:end)=1;
0212   B([1:imRadius end-imRadius:end],:)=0;
0213   B(:,[1:imRadius end-imRadius:end])=0;
0214   <span class="keyword">for</span> j=1:nGt
0215     M=gt{j}.Boundaries; M(bwdist(M)&lt;gtRadius)=1;
0216     [y,x]=find(M.*B); k2=min(length(y),ceil(nPos/nImgs/nGt));
0217     rp=randperm(length(y),k2); y=y(rp); x=x(rp);
0218     xy=[xy; x y ones(k2,1)*j]; k1=k1+k2; <span class="comment">%#ok&lt;AGROW&gt;</span>
0219     [y,x]=find(~M.*B); k2=min(length(y),ceil(nNeg/nImgs/nGt));
0220     rp=randperm(length(y),k2); y=y(rp); x=x(rp);
0221     xy=[xy; x y ones(k2,1)*j]; k1=k1+k2; <span class="comment">%#ok&lt;AGROW&gt;</span>
0222   <span class="keyword">end</span>
0223   <span class="keyword">if</span>(k1&gt;size(ftrs,1)-k), k1=size(ftrs,1)-k; xy=xy(1:k1,:); <span class="keyword">end</span>
0224   <span class="comment">% crop patches and ground truth labels</span>
0225   psReg=zeros(imWidth/shrink,imWidth/shrink,nChns,k1,<span class="string">'single'</span>);
0226   lbls=zeros(gtWidth,gtWidth,k1,<span class="string">'uint8'</span>);
0227   psSim=psReg; ri=imRadius/shrink; rg=gtRadius;
0228   <span class="keyword">for</span> j=1:k1, xy1=xy(j,:); xy2=xy1/shrink;
0229     psReg(:,:,:,j)=chnsReg(xy2(2)-ri+1:xy2(2)+ri,xy2(1)-ri+1:xy2(1)+ri,:);
0230     psSim(:,:,:,j)=chnsSim(xy2(2)-ri+1:xy2(2)+ri,xy2(1)-ri+1:xy2(1)+ri,:);
0231     t=gt{xy1(3)}.Segmentation(xy1(2)-rg+1:xy1(2)+rg,xy1(1)-rg+1:xy1(1)+rg);
0232     <span class="keyword">if</span>(all(t(:)==t(1))), lbls(:,:,j)=1; <span class="keyword">else</span> [~,~,t]=unique(t);
0233       lbls(:,:,j)=reshape(t,gtWidth,gtWidth); <span class="keyword">end</span>
0234   <span class="keyword">end</span>
0235   <span class="keyword">if</span>(0), figure(1); montage2(squeeze(psReg(:,:,1,:))); drawnow; <span class="keyword">end</span>
0236   <span class="keyword">if</span>(0), figure(2); montage2(lbls(:,:,:)); drawnow; <span class="keyword">end</span>
0237   <span class="comment">% compute features and store</span>
0238   ftrs1=[reshape(psReg,[],k1)' <a href="#_sub3" class="code" title="subfunction ftrs = stComputeSimFtrs( chns, opts )">stComputeSimFtrs</a>(psSim,opts)];
0239   ftrs(k+1:k+k1,:)=ftrs1(:,fids); labels(:,:,k+1:k+k1)=lbls;
0240   k=k+k1; <span class="keyword">if</span>(k==size(ftrs,1)), tocStatus(tid,1); <span class="keyword">break</span>; <span class="keyword">end</span>
0241   tocStatus(tid,i/nImgs);
0242 <span class="keyword">end</span>
0243 <span class="keyword">if</span>(k&lt;size(ftrs,1)), ftrs=ftrs(1:k,:); labels=labels(:,:,1:k); <span class="keyword">end</span>
0244 
0245 <span class="comment">% train structured edge classifier (random decision tree)</span>
0246 pTree=struct(<span class="string">'minCount'</span>,opts.minCount, <span class="string">'minChild'</span>,opts.minChild, <span class="keyword">...</span>
0247   <span class="string">'maxDepth'</span>,opts.maxDepth, <span class="string">'H'</span>,opts.nClasses, <span class="string">'split'</span>,opts.split);
0248 t=labels; labels=cell(k,1); <span class="keyword">for</span> i=1:k, labels{i}=t(:,:,i); <span class="keyword">end</span>
0249 pTree.discretize=@(hs,H) <a href="#_sub4" class="code" title="subfunction [hs,segs] = discretize( segs, nClasses, nSamples, type )">discretize</a>(hs,H,opts.nSamples,opts.discretize);
0250 tree=forestTrain(ftrs,labels,pTree); tree.hs=cell2array(tree.hs);
0251 tree.fids(tree.child&gt;0) = fids(tree.fids(tree.child&gt;0)+1)-1;
0252 <span class="keyword">if</span>(~exist(treeDir,<span class="string">'dir'</span>)), mkdir(treeDir); <span class="keyword">end</span>
0253 save([treeFn int2str2(treeInd,3) <span class="string">'.mat'</span>],<span class="string">'tree'</span>); e=etime(clock,tStart);
0254 fprintf(<span class="string">'Training of tree %d complete (time=%.1fs).\n'</span>,treeInd,e);
0255 RandStream.setGlobalStream( streamOrig );
0256 
0257 <span class="keyword">end</span>
0258 
0259 <a name="_sub3" href="#_subfunctions" class="code">function ftrs = stComputeSimFtrs( chns, opts )</a>
0260 <span class="comment">% Compute self-similarity features (order must be compatible w mex file).</span>
0261 w=opts.imWidth/opts.shrink; n=opts.nCells; <span class="keyword">if</span>(n==0), ftrs=[]; <span class="keyword">return</span>; <span class="keyword">end</span>
0262 nSimFtrs=opts.nSimFtrs; nChns=opts.nChns; m=size(chns,4);
0263 inds=round(w/n/2); inds=round((1:n)*(w+2*inds-1)/(n+1)-inds+1);
0264 chns=reshape(chns(inds,inds,:,:),n*n,nChns,m);
0265 ftrs=zeros(nSimFtrs/nChns,nChns,m,<span class="string">'single'</span>);
0266 k=0; <span class="keyword">for</span> i=1:n*n-1, k1=n*n-i; i1=ones(1,k1)*i;
0267   ftrs(k+1:k+k1,:,:)=chns(i1,:,:)-chns((1:k1)+i,:,:); k=k+k1; <span class="keyword">end</span>
0268 ftrs = reshape(ftrs,nSimFtrs,m)';
0269 <span class="keyword">end</span>
0270 
0271 <a name="_sub4" href="#_subfunctions" class="code">function [hs,segs] = discretize( segs, nClasses, nSamples, type )</a>
0272 <span class="comment">% Convert a set of segmentations into a set of labels in [1,nClasses].</span>
0273 <span class="keyword">persistent</span> cache; w=size(segs{1},1); assert(size(segs{1},2)==w);
0274 <span class="keyword">if</span>(~isempty(cache) &amp;&amp; cache{1}==w), [~,is1,is2]=deal(cache{:}); <span class="keyword">else</span>
0275   <span class="comment">% compute all possible lookup inds for w x w patches</span>
0276   is=1:w^4; is1=floor((is-1)/w/w); is2=is-is1*w*w; is1=is1+1;
0277   kp=is2&gt;is1; is1=is1(kp); is2=is2(kp); cache={w,is1,is2};
0278 <span class="keyword">end</span>
0279 <span class="comment">% compute n binary codes zs of length nSamples</span>
0280 nSamples=min(nSamples,length(is1)); kp=randperm(length(is1),nSamples);
0281 n=length(segs); is1=is1(kp); is2=is2(kp); zs=false(n,nSamples);
0282 <span class="keyword">for</span> i=1:n, zs(i,:)=segs{i}(is1)==segs{i}(is2); <span class="keyword">end</span>
0283 zs=bsxfun(@minus,zs,sum(zs,1)/n); zs=zs(:,any(zs,1));
0284 <span class="keyword">if</span>(isempty(zs)), hs=ones(n,1,<span class="string">'uint32'</span>); segs=segs{1}; <span class="keyword">return</span>; <span class="keyword">end</span>
0285 <span class="comment">% find most representative segs (closest to mean)</span>
0286 [~,ind]=min(sum(zs.*zs,2)); segs=segs{ind};
0287 <span class="comment">% apply PCA to reduce dimensionality of zs</span>
0288 U=pca(zs'); d=min(5,size(U,2)); zs=zs*U(:,1:d);
0289 <span class="comment">% discretize zs by clustering or discretizing pca dimensions</span>
0290 d=min(d,floor(log2(nClasses))); hs=zeros(n,1);
0291 <span class="keyword">for</span> i=1:d, hs=hs+(zs(:,i)&lt;0)*2^(i-1); <span class="keyword">end</span>
0292 [~,~,hs]=unique(hs); hs=uint32(hs);
0293 <span class="keyword">if</span>(strcmpi(type,<span class="string">'kmeans'</span>))
0294   nClasses1=max(hs); C=zs(1:nClasses1,:);
0295   <span class="keyword">for</span> i=1:nClasses1, C(i,:)=mean(zs(hs==i,:),1); <span class="keyword">end</span>
0296   hs=uint32(kmeans2(zs,nClasses,<span class="string">'C0'</span>,C,<span class="string">'nIter'</span>,1));
0297 <span class="keyword">end</span>
0298 <span class="comment">% optionally display different types of hs</span>
0299 <span class="keyword">for</span> i=1:0, figure(i); montage2(cell2array(segs(hs==i))); <span class="keyword">end</span>
0300 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>