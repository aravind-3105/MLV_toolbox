<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of meanShift</title>
  <meta name="keywords" content="meanShift">
  <meta name="description" content="meanShift clustering algorithm.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">classify</a> &gt; meanShift.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\classify&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>meanShift
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>meanShift clustering algorithm.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [IDX,M] = meanShift(X, radius, rate, maxIter, minCsize, blur ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> meanShift clustering algorithm.

 Based on code from Sameer Agarwal &lt;sagarwal-at-cs.ucsd.edu&gt;.
 For a broad discussion see:
 Y. Cheng, Mean-shift, mode seeking, and clustering, IEEE Transactions on
 Pattern Analysis and Machine Intelligence, Vol.17, 1995, pp. 790-799

 The radius or bandwidth is tied to the 'width' of the distribution and is
 data dependent.  Note that the data should be normalized first so that
 all the dimensions have the same bandwidth.  The rate determines how
 large the gradient decent steps are.  The smaller the rate, the more
 iterations are needed for convergence, but the more likely minima are not
 overshot.  A reasonable value for the rate is .2.  Low value of the rate
 may require an increase in maxIter.  Increase maxIter until convergence
 occurs regularly for a given data set (versus the algorithm being cut off
 at maxIter).

 Note the cluster means M do not refer to the actual mean of the points
 that belong to the same cluster, but rather the values to which the
 meanShift algorithm converged for each given point (recall that cluster
 membership is based on the mean converging to the same value from
 different points).  Hence M is not the same as C, the centroid of the
 points [see kmeans2 for a definition of C].

 USAGE
  [IDX,M] = meanShift(X, radius, [rate], [maxIter], [minCsize], [blur] )

 INPUTS
  X           - column vector of data - N vectors of dim p (X is Nxp)
  radius      - the bandwidth (radius of the window)
  rate        - [] gradient descent proportionality factor in (0,1]
  maxIter     - [] maximum number of iterations
  minCsize    - [] min cluster size (smaller clusters get eliminated)
  blur        - [] if blur then at each iter data is 'blurred', ie the
                original data points move (can cause 'incorrect' results)

 OUTPUTS
  IDX         - cluster membership [see kmeans2.m]
  M           - cluster means [see above]

 EXAMPLE

 See also <a href="meanShiftIm.html" class="code" title="function [M,Vr,Vc] = meanShiftIm( X,sigSpt,sigRng,softFlag,maxIter,minDel )">MEANSHIFTIM</a>, <a href="demoCluster.html" class="code" title="">DEMOCLUSTER</a>

 Piotr's Computer Vision Matlab Toolbox      Version 2.0
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="demoCluster.html" class="code" title="">demoCluster</a>	Clustering demo.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [IDX,M] = meanShift(X, radius, rate, maxIter, minCsize, blur )</a>
0002 <span class="comment">% meanShift clustering algorithm.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Based on code from Sameer Agarwal &lt;sagarwal-at-cs.ucsd.edu&gt;.</span>
0005 <span class="comment">% For a broad discussion see:</span>
0006 <span class="comment">% Y. Cheng, Mean-shift, mode seeking, and clustering, IEEE Transactions on</span>
0007 <span class="comment">% Pattern Analysis and Machine Intelligence, Vol.17, 1995, pp. 790-799</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% The radius or bandwidth is tied to the 'width' of the distribution and is</span>
0010 <span class="comment">% data dependent.  Note that the data should be normalized first so that</span>
0011 <span class="comment">% all the dimensions have the same bandwidth.  The rate determines how</span>
0012 <span class="comment">% large the gradient decent steps are.  The smaller the rate, the more</span>
0013 <span class="comment">% iterations are needed for convergence, but the more likely minima are not</span>
0014 <span class="comment">% overshot.  A reasonable value for the rate is .2.  Low value of the rate</span>
0015 <span class="comment">% may require an increase in maxIter.  Increase maxIter until convergence</span>
0016 <span class="comment">% occurs regularly for a given data set (versus the algorithm being cut off</span>
0017 <span class="comment">% at maxIter).</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% Note the cluster means M do not refer to the actual mean of the points</span>
0020 <span class="comment">% that belong to the same cluster, but rather the values to which the</span>
0021 <span class="comment">% meanShift algorithm converged for each given point (recall that cluster</span>
0022 <span class="comment">% membership is based on the mean converging to the same value from</span>
0023 <span class="comment">% different points).  Hence M is not the same as C, the centroid of the</span>
0024 <span class="comment">% points [see kmeans2 for a definition of C].</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% USAGE</span>
0027 <span class="comment">%  [IDX,M] = meanShift(X, radius, [rate], [maxIter], [minCsize], [blur] )</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% INPUTS</span>
0030 <span class="comment">%  X           - column vector of data - N vectors of dim p (X is Nxp)</span>
0031 <span class="comment">%  radius      - the bandwidth (radius of the window)</span>
0032 <span class="comment">%  rate        - [] gradient descent proportionality factor in (0,1]</span>
0033 <span class="comment">%  maxIter     - [] maximum number of iterations</span>
0034 <span class="comment">%  minCsize    - [] min cluster size (smaller clusters get eliminated)</span>
0035 <span class="comment">%  blur        - [] if blur then at each iter data is 'blurred', ie the</span>
0036 <span class="comment">%                original data points move (can cause 'incorrect' results)</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% OUTPUTS</span>
0039 <span class="comment">%  IDX         - cluster membership [see kmeans2.m]</span>
0040 <span class="comment">%  M           - cluster means [see above]</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% EXAMPLE</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also MEANSHIFTIM, DEMOCLUSTER</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 2.0</span>
0047 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0048 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0049 
0050 <span class="keyword">if</span>( nargin&lt;3 ); rate =.2; <span class="keyword">end</span>
0051 <span class="keyword">if</span>( nargin&lt;4 ); maxIter =100; <span class="keyword">end</span>
0052 <span class="keyword">if</span>( nargin&lt;5 ); minCsize = 1; <span class="keyword">end</span>
0053 <span class="keyword">if</span>( nargin&lt;6 ); blur =0; <span class="keyword">end</span>
0054 <span class="keyword">if</span>( rate&lt;=0 || rate&gt;1 ); error(<span class="string">'rate must be between 0 and 1'</span>); <span class="keyword">end</span>
0055 
0056 <span class="comment">% OLD VERSION OF rate (gradient descent proportionality factor)</span>
0057 <span class="comment">% rate = rate * (size(X,2) + 2) / radius^2;</span>
0058 
0059 <span class="comment">% c code does the work  (meanShift1 requires X')</span>
0060 [IDX,meansFinal] = meanShift1(X',radius,rate,maxIter,blur);
0061 meansFinal = meansFinal';
0062 
0063 <span class="comment">% calculate final cluster means per cluster</span>
0064 p = size(X,2);  k = max(IDX);
0065 M = zeros(k,p); <span class="keyword">for</span> i=1:k; M(i,:) = mean( meansFinal(IDX==i,:), 1 ); <span class="keyword">end</span>
0066 
0067 <span class="comment">% sort clusters [largest first] and remove all smaller then minCsize</span>
0068 ccounts = zeros(1,k); <span class="keyword">for</span> i=1:k; ccounts(i) = sum( IDX==i ); <span class="keyword">end</span>
0069 [ccounts,order] = sort( -ccounts ); ccounts = -ccounts; M = M(order,:);
0070 IDX2 = IDX;  <span class="keyword">for</span> i=1:k; IDX2(IDX==order(i))=i; <span class="keyword">end</span>; IDX = IDX2;
0071 [v,loc] = min( ccounts&gt;=minCsize );
0072 <span class="keyword">if</span>( v==0 ); M( loc:<span class="keyword">end</span>, : ) = []; IDX( IDX&gt;=loc ) = -1; <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>