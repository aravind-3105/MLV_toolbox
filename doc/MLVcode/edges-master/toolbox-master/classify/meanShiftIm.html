<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of meanShiftIm</title>
  <meta name="keywords" content="meanShiftIm">
  <meta name="description" content="Applies the meanShift algorithm to a joint spatial/range image.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">classify</a> &gt; meanShiftIm.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\classify&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>meanShiftIm
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Applies the meanShift algorithm to a joint spatial/range image.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [M,Vr,Vc] = meanShiftIm( X,sigSpt,sigRng,softFlag,maxIter,minDel ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Applies the meanShift algorithm to a joint spatial/range image.

 See &quot;Mean Shift Analysis and Applications&quot; by Comaniciu &amp; Meer for info.

 Assumes X is an MxNxP array, where an X(i,j,:) represents the range data
 at locations (i,j).  This function runs meanShift on each of the MxN data
 points.  It takes advantage of the lattice structure of an image for
 efficiency (it only needs to calculate full distance between two points
 if they are near each other spatially).

 In the original formulation of the algorithm, after normalization of the
 data, the search window around each point x has radius 1 (ie
 corresponding to 1 std of the data). That is the search window only
 encloses 2*s+1 pixels, and of those, all which fall within 1 unit from x
 are used to calcluate the new mean.  If softFlag==0 the original
 formulation is used.  If softFlag==1, instead of using a fixed radius,
 each point p is used in the calulation of the mean with points close to x
 given significantly more weight.  Specifically, each point p is given
 weight exp(-dist(x,p)).  So instead of having a fixed cutoff at r, the
 cutoff is 'soft' (same idea as in softmax), and occurs at approximately
 r.  The implementation remains efficient by actually using a hard cutoff
 at points further then 2r spatially from x.

 The resulting matrix M is of size MxNx(P+2).  M(i,j,1) represents the
 convergent row location of X(i,j,:) - (which had initial row location i)
 and M(i,j,2) represents the final column location.  M(i,j,p+2) represents
 the convergent value for X(i,j,p).  The optionaly outputs Vr and Vc are
 2D arrays where Vr(i,j)=M(i,j,1)-i and Vc(i,j)=M(i,j,2)-j.  That is they
 represent the spatial offset between the original location of a point and
 its convergent location.  Display using quiver(Vc,Vr,0).

 USAGE
  [M,Vr,Vc] = meanShiftIm( X,sigSpt,sigRng,[softFlag],[maxIter],[minDel] )

 INPUTS
  X        - MxNxP data array, P may be 1
  sigSpt   - integer specifying spatial standard deviation
  sigRng   - value specifying the standard deviation of the range data
  softFlag - [0]- see above
  maxIter  - [100] maximum number of iterations per data point
  minDel   - [.001] minimum amount of spatial change defining convergence

 OUTPUTS
  M        - array of convergent locations [see above]
  Vr       - spatial motion in row direction
  Vc       - spatial motion in col direction

 EXAMPLE
  I=double(imread('cameraman.tif'))/255;
  [M,Vr,Vc] = meanShiftIm( I,5,.2 );
  figure(1); im(I); figure(2); im( M(:,:,3) );
  % color image:
  I=double(imread('hestain.png'))/255;
  [M,Vr,Vc] = meanShiftIm( I,5,.2 );
  figure(1); im(I); figure(2); im( M(:,:,3:end) );

 See also <a href="meanShift.html" class="code" title="function [IDX,M] = meanShift(X, radius, rate, maxIter, minCsize, blur )">MEANSHIFT</a>, <a href="meanShiftImExplore.html" class="code" title="function meanShiftImExplore( I, X, sigSpt, sigRng, show )">MEANSHIFTIMEXPLORE</a>

 Piotr's Computer Vision Matlab Toolbox      Version 2.0
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [M,Vr,Vc] = meanShiftIm( X,sigSpt,sigRng,softFlag,maxIter,minDel )</a>
0002 <span class="comment">% Applies the meanShift algorithm to a joint spatial/range image.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% See &quot;Mean Shift Analysis and Applications&quot; by Comaniciu &amp; Meer for info.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Assumes X is an MxNxP array, where an X(i,j,:) represents the range data</span>
0007 <span class="comment">% at locations (i,j).  This function runs meanShift on each of the MxN data</span>
0008 <span class="comment">% points.  It takes advantage of the lattice structure of an image for</span>
0009 <span class="comment">% efficiency (it only needs to calculate full distance between two points</span>
0010 <span class="comment">% if they are near each other spatially).</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% In the original formulation of the algorithm, after normalization of the</span>
0013 <span class="comment">% data, the search window around each point x has radius 1 (ie</span>
0014 <span class="comment">% corresponding to 1 std of the data). That is the search window only</span>
0015 <span class="comment">% encloses 2*s+1 pixels, and of those, all which fall within 1 unit from x</span>
0016 <span class="comment">% are used to calcluate the new mean.  If softFlag==0 the original</span>
0017 <span class="comment">% formulation is used.  If softFlag==1, instead of using a fixed radius,</span>
0018 <span class="comment">% each point p is used in the calulation of the mean with points close to x</span>
0019 <span class="comment">% given significantly more weight.  Specifically, each point p is given</span>
0020 <span class="comment">% weight exp(-dist(x,p)).  So instead of having a fixed cutoff at r, the</span>
0021 <span class="comment">% cutoff is 'soft' (same idea as in softmax), and occurs at approximately</span>
0022 <span class="comment">% r.  The implementation remains efficient by actually using a hard cutoff</span>
0023 <span class="comment">% at points further then 2r spatially from x.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% The resulting matrix M is of size MxNx(P+2).  M(i,j,1) represents the</span>
0026 <span class="comment">% convergent row location of X(i,j,:) - (which had initial row location i)</span>
0027 <span class="comment">% and M(i,j,2) represents the final column location.  M(i,j,p+2) represents</span>
0028 <span class="comment">% the convergent value for X(i,j,p).  The optionaly outputs Vr and Vc are</span>
0029 <span class="comment">% 2D arrays where Vr(i,j)=M(i,j,1)-i and Vc(i,j)=M(i,j,2)-j.  That is they</span>
0030 <span class="comment">% represent the spatial offset between the original location of a point and</span>
0031 <span class="comment">% its convergent location.  Display using quiver(Vc,Vr,0).</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% USAGE</span>
0034 <span class="comment">%  [M,Vr,Vc] = meanShiftIm( X,sigSpt,sigRng,[softFlag],[maxIter],[minDel] )</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% INPUTS</span>
0037 <span class="comment">%  X        - MxNxP data array, P may be 1</span>
0038 <span class="comment">%  sigSpt   - integer specifying spatial standard deviation</span>
0039 <span class="comment">%  sigRng   - value specifying the standard deviation of the range data</span>
0040 <span class="comment">%  softFlag - [0]- see above</span>
0041 <span class="comment">%  maxIter  - [100] maximum number of iterations per data point</span>
0042 <span class="comment">%  minDel   - [.001] minimum amount of spatial change defining convergence</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% OUTPUTS</span>
0045 <span class="comment">%  M        - array of convergent locations [see above]</span>
0046 <span class="comment">%  Vr       - spatial motion in row direction</span>
0047 <span class="comment">%  Vc       - spatial motion in col direction</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% EXAMPLE</span>
0050 <span class="comment">%  I=double(imread('cameraman.tif'))/255;</span>
0051 <span class="comment">%  [M,Vr,Vc] = meanShiftIm( I,5,.2 );</span>
0052 <span class="comment">%  figure(1); im(I); figure(2); im( M(:,:,3) );</span>
0053 <span class="comment">%  % color image:</span>
0054 <span class="comment">%  I=double(imread('hestain.png'))/255;</span>
0055 <span class="comment">%  [M,Vr,Vc] = meanShiftIm( I,5,.2 );</span>
0056 <span class="comment">%  figure(1); im(I); figure(2); im( M(:,:,3:end) );</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% See also MEANSHIFT, MEANSHIFTIMEXPLORE</span>
0059 <span class="comment">%</span>
0060 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 2.0</span>
0061 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0062 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0063 
0064 [sigSpt,er] = checkNumArgs( sigSpt, 1, 0, 1 ); error(er);
0065 <span class="keyword">if</span>( nargin&lt;4 || isempty(softFlag)); softFlag = 0; <span class="keyword">end</span>
0066 <span class="keyword">if</span>( nargin&lt;5 || isempty(maxIter) ); maxIter = 100; <span class="keyword">end</span>
0067 <span class="keyword">if</span>( nargin&lt;6 || isempty(minDel)); minDel = .001; <span class="keyword">end</span>
0068 
0069 [mrows, ncols, p] = size(X); p = p+2;
0070 [gridRs, gridCs] = ndgrid( 1:mrows, 1:ncols );
0071 data = cat( 3, cat( 3, gridRs/sigSpt, gridCs/sigSpt), X/sigRng );
0072 
0073 <span class="comment">%%% MAIN LOOP</span>
0074 M = data;
0075 ticId = ticStatus(<span class="string">'meanShiftIm'</span>);  <span class="comment">%t0 = clock;  tlast = t0;</span>
0076 <span class="keyword">if</span>( softFlag ); radius = sigSpt*2; <span class="keyword">else</span> radius = sigSpt; <span class="keyword">end</span>
0077 <span class="keyword">for</span> i=1:mrows; <span class="keyword">for</span> j=1:ncols; <span class="comment">%#ok&lt;ALIGN&gt;</span>
0078     Mij = data(i,j,:); Mij = Mij(:)';
0079     itercount = 0; diff = 1;
0080     <span class="keyword">while</span>( itercount &lt; maxIter &amp;&amp; diff&gt;minDel )
0081 
0082       <span class="comment">% get data which is possibly relevant (within spatial range)</span>
0083       r = round( Mij(1)*sigSpt );  c = round( Mij(2)*sigSpt );
0084       boundsr = max(1,r-radius):min(mrows,r+radius);
0085       boundsc = max(1,c-radius):min(ncols,c+radius);
0086       dataWin = data( boundsr, boundsc, : );
0087       dataWinF = reshape( dataWin, [], p );
0088 
0089       <span class="comment">% get next mean</span>
0090       MijOld = Mij;
0091       n = size( dataWinF, 1);
0092       D = sum( (dataWinF - ones(n,1)*Mij).^2, 2 );
0093       <span class="keyword">if</span>( softFlag )
0094         S = exp( -D ); sumS = sum(S); Srep = S(:,ones(1,p));
0095         Mij = sum( dataWinF .* Srep, 1 ) / sumS;
0096       <span class="keyword">else</span>
0097         dataWinF = dataWinF( D &lt; 1, : );
0098         Mij = sum( dataWinF, 1 ) / size( dataWinF,1 );
0099       <span class="keyword">end</span>
0100 
0101       <span class="comment">% check if Mij changed [only on basis of x,y location]</span>
0102       diff = sum( (MijOld(1:2)-Mij(1:2)).^2 );
0103       itercount = itercount+1;
0104 
0105     <span class="keyword">end</span>
0106     M(i,j,:) = Mij(:);
0107     fracdone = ((i-1)*ncols+j) / (mrows*ncols);
0108     tocStatus( ticId, fracdone );
0109   <span class="keyword">end</span>
0110 <span class="keyword">end</span>
0111 M = cat(3, M(:,:,1:2)*sigSpt, M(:,:,3:end)*sigRng );
0112 
0113 <span class="comment">%%% Output spatial difference</span>
0114 <span class="keyword">if</span>( nargout&gt;1 )
0115   Vr = M(:,:,1)-gridRs;  Vc = M(:,:,2)-gridCs;
0116 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>