<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of imagesAlignSeq</title>
  <meta name="keywords" content="imagesAlignSeq">
  <meta name="description" content="Stabilize image sequence using coarse optical flow estimation.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">videos</a> &gt; imagesAlignSeq.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\videos&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>imagesAlignSeq
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Stabilize image sequence using coarse optical flow estimation.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [J,Vxs,Vys] = imagesAlignSeq( I, pFlow, type, bndThr ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Stabilize image sequence using coarse optical flow estimation.

 Perform weak image sequence stabilization as described in:
  D. Park, C. Zitnick, D. Ramanan and P. Dollár
  &quot;Exploring Weak Stabilization for Motion Feature Extraction&quot;, CVPR 2013.
 The approach stabilizes coarse motion due to camera movement but leaves
 independent object motions intact. This code performs weak sequence
 stabilization only (no feature extraction), see section 3.1 of the paper.
 Please cite the above paper if you end up using the stabilization code.

 Optical flow is computed between all pairs of frames using opticalFlow.m
 with params 'pFlow'. Flow across multiple frames is accumulated and flow
 at integer locations at each stage is obtained either using either
 nearest neighbor (if type==1) or bilinear interpolation (if type==2)
 which is slightly more accurate but slower. Finally, all images in I are
 warped to the last frame of the sequence using the accumulated flows. If
 type==-1, a homography computed via imagesAlign.m with params pFlow is
 used instead. If videos have black boundaries use bndThr to ignore dark
 boundaries for flow estimation (with average pixel values under bndThr).

 USAGE
  [J,Vxs,Vys] = imagesAlignSeq( I, pFlow, [type], [bndThr] )

 INPUTS
  I          - HxWxN or HxWx3xN input image sequence
  pFlow      - parameters to use for optical flow computation
  type       - [1] interpolation type 1:nearest, 2:bilinear
  bndThr     - [0] fill in black areas around image boundaries

 OUTPUTS
  J          - HxWxN or HxWx3xN stabilized image sequence
  Vxs        - HxWxN-1 x-components of flow fields
  Vys        - HxWxN-1 y-components of flow fields

 EXAMPLE
  I = seqIo(which('peds30.seq'),'toImgs'); I=I(:,:,:,1:15);
  pFlow={'smooth',1,'radius',25,'type','LK','maxScale',1};
  tic, J = imagesAlignSeq( I, pFlow, 1, 20 ); toc
  playMovie([I J],15,-10,struct('hasChn',1))

 EXAMPLE
  % Requires Caltech Pedestrian Dataset to be installed
  [pth,ss,vs]=dbInfo; s=randi(length(ss)); v=randi(length(vs{s}));
  nm=sprintf('%s/videos/set%02i/V%03i.seq',pth,ss(s),vs{s}(v));
  f=seqIo(nm,'getinfo'); f=f.numFrames; f=randi(f-30);
  I=seqIo(nm,'toImgs',[],1,f,f+9);
  pFlow={'smooth',1,'radius',25,'type','LK','maxScale',1};
  tic, J = imagesAlignSeq( I, pFlow, 1, 20 ); toc
  playMovie([I J],15,-10,struct('hasChn',1))

 See also <a href="opticalFlow.html" class="code" title="function [Vx,Vy,reliab] = opticalFlow( I1, I2, varargin )">opticalFlow</a>, imtransform2, <a href="imagesAlign.html" class="code" title="function [H,Ip] = imagesAlign( I, Iref, varargin )">imagesAlign</a>

 Piotr's Computer Vision Matlab Toolbox      Version 3.24
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="imagesAlign.html" class="code" title="function [H,Ip] = imagesAlign( I, Iref, varargin )">imagesAlign</a>	Fast and robust estimation of homography relating two images.</li><li><a href="opticalFlow.html" class="code" title="function [Vx,Vy,reliab] = opticalFlow( I1, I2, varargin )">opticalFlow</a>	Coarse-to-fine optical flow using Lucas&Kanade or Horn&Schunck.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Vx,Vy] = interpolate( Vx, Vy, X, Y, type )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [J,Vxs,Vys] = imagesAlignSeq( I, pFlow, type, bndThr )</a>
0002 <span class="comment">% Stabilize image sequence using coarse optical flow estimation.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Perform weak image sequence stabilization as described in:</span>
0005 <span class="comment">%  D. Park, C. Zitnick, D. Ramanan and P. Dollár</span>
0006 <span class="comment">%  &quot;Exploring Weak Stabilization for Motion Feature Extraction&quot;, CVPR 2013.</span>
0007 <span class="comment">% The approach stabilizes coarse motion due to camera movement but leaves</span>
0008 <span class="comment">% independent object motions intact. This code performs weak sequence</span>
0009 <span class="comment">% stabilization only (no feature extraction), see section 3.1 of the paper.</span>
0010 <span class="comment">% Please cite the above paper if you end up using the stabilization code.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Optical flow is computed between all pairs of frames using opticalFlow.m</span>
0013 <span class="comment">% with params 'pFlow'. Flow across multiple frames is accumulated and flow</span>
0014 <span class="comment">% at integer locations at each stage is obtained either using either</span>
0015 <span class="comment">% nearest neighbor (if type==1) or bilinear interpolation (if type==2)</span>
0016 <span class="comment">% which is slightly more accurate but slower. Finally, all images in I are</span>
0017 <span class="comment">% warped to the last frame of the sequence using the accumulated flows. If</span>
0018 <span class="comment">% type==-1, a homography computed via imagesAlign.m with params pFlow is</span>
0019 <span class="comment">% used instead. If videos have black boundaries use bndThr to ignore dark</span>
0020 <span class="comment">% boundaries for flow estimation (with average pixel values under bndThr).</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% USAGE</span>
0023 <span class="comment">%  [J,Vxs,Vys] = imagesAlignSeq( I, pFlow, [type], [bndThr] )</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% INPUTS</span>
0026 <span class="comment">%  I          - HxWxN or HxWx3xN input image sequence</span>
0027 <span class="comment">%  pFlow      - parameters to use for optical flow computation</span>
0028 <span class="comment">%  type       - [1] interpolation type 1:nearest, 2:bilinear</span>
0029 <span class="comment">%  bndThr     - [0] fill in black areas around image boundaries</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% OUTPUTS</span>
0032 <span class="comment">%  J          - HxWxN or HxWx3xN stabilized image sequence</span>
0033 <span class="comment">%  Vxs        - HxWxN-1 x-components of flow fields</span>
0034 <span class="comment">%  Vys        - HxWxN-1 y-components of flow fields</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% EXAMPLE</span>
0037 <span class="comment">%  I = seqIo(which('peds30.seq'),'toImgs'); I=I(:,:,:,1:15);</span>
0038 <span class="comment">%  pFlow={'smooth',1,'radius',25,'type','LK','maxScale',1};</span>
0039 <span class="comment">%  tic, J = imagesAlignSeq( I, pFlow, 1, 20 ); toc</span>
0040 <span class="comment">%  playMovie([I J],15,-10,struct('hasChn',1))</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% EXAMPLE</span>
0043 <span class="comment">%  % Requires Caltech Pedestrian Dataset to be installed</span>
0044 <span class="comment">%  [pth,ss,vs]=dbInfo; s=randi(length(ss)); v=randi(length(vs{s}));</span>
0045 <span class="comment">%  nm=sprintf('%s/videos/set%02i/V%03i.seq',pth,ss(s),vs{s}(v));</span>
0046 <span class="comment">%  f=seqIo(nm,'getinfo'); f=f.numFrames; f=randi(f-30);</span>
0047 <span class="comment">%  I=seqIo(nm,'toImgs',[],1,f,f+9);</span>
0048 <span class="comment">%  pFlow={'smooth',1,'radius',25,'type','LK','maxScale',1};</span>
0049 <span class="comment">%  tic, J = imagesAlignSeq( I, pFlow, 1, 20 ); toc</span>
0050 <span class="comment">%  playMovie([I J],15,-10,struct('hasChn',1))</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% See also opticalFlow, imtransform2, imagesAlign</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.24</span>
0055 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0056 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0057 
0058 <span class="comment">% default parameters</span>
0059 <span class="keyword">if</span>(nargin&lt;3 || isempty(type)), type=1; <span class="keyword">end</span>
0060 <span class="keyword">if</span>(nargin&lt;4 || isempty(bndThr)), bndThr=0; <span class="keyword">end</span>
0061 
0062 <span class="comment">% fill in black areas around image boundaries</span>
0063 [h,w,k,n]=size(I); <span class="keyword">if</span>(n&gt;1), assert(k==3); <span class="keyword">else</span> n=k; k=1; <span class="keyword">end</span>
0064 <span class="keyword">for</span> t=1:n, <span class="keyword">if</span>(bndThr&lt;=0), <span class="keyword">break</span>; <span class="keyword">end</span>; is=(1:k)+(t*k-k);
0065   xs=find(sum(sum(I(:,:,is),1),3)&gt;k*h*bndThr);
0066   ys=find(sum(sum(I(:,:,is),2),3)&gt;k*w*bndThr);
0067   <span class="keyword">if</span>(isempty(xs)||isempty(ys)), error(<span class="string">'bndThr set too high'</span>); <span class="keyword">end</span>
0068   pad=[ys(1)-1 h-ys(end) xs(1)-1 w-xs(end)];
0069   I(:,:,is)=imPad(imPad(I(:,:,is),-pad,0),pad,<span class="string">'replicate'</span>);
0070 <span class="keyword">end</span>
0071 <span class="keyword">if</span>(k==1), G=I; <span class="keyword">else</span> G=rgbConvert(I,<span class="string">'gray'</span>); <span class="keyword">end</span>; J=I;
0072 
0073 <span class="comment">% special case if type==-1 use homographies for alignment</span>
0074 <span class="keyword">if</span>( type==-1 )
0075   Hs=zeros(3,3,n-1); Gref=G(:,:,end);
0076   <span class="keyword">for</span> t=1:n-1, is=(1:k)+(t*k-k);
0077     Hs(:,:,t) = <a href="imagesAlign.html" class="code" title="function [H,Ip] = imagesAlign( I, Iref, varargin )">imagesAlign</a>(G(:,:,t),Gref,pFlow);
0078     J(:,:,is) = imtransform2(I(:,:,is), Hs(:,:,t),<span class="string">'pad'</span>,<span class="string">'replicate'</span>);
0079   <span class="keyword">end</span>; Vxs=Hs; Vys=Hs; <span class="keyword">return</span>;
0080 <span class="keyword">end</span>
0081 
0082 <span class="comment">% compute flow between each pair of images in reverse direction</span>
0083 Vxs=cell(1,n-1); Vys=Vxs;
0084 <span class="keyword">for</span> t=1:n-1, [Vxs{t},Vys{t}]=<a href="opticalFlow.html" class="code" title="function [Vx,Vy,reliab] = opticalFlow( I1, I2, varargin )">opticalFlow</a>(G(:,:,t+1),G(:,:,t),pFlow); <span class="keyword">end</span>
0085 
0086 <span class="comment">% accumulate flow across frames</span>
0087 Vx=Vxs{end}; Vy=Vys{end}; [X,Y]=meshgrid(1:w,1:h);
0088 <span class="keyword">for</span> t=n-2:-1:1
0089   [Vxt,Vyt] = <a href="#_sub1" class="code" title="subfunction [Vx,Vy] = interpolate( Vx, Vy, X, Y, type )">interpolate</a>(Vxs{t},Vys{t},X+Vx,Y+Vy,type);
0090   Vx=Vx+Vxt; Vxs{t}=Vx; Vy=Vy+Vyt; Vys{t}=Vy;
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% transform each I by given flow</span>
0094 <span class="keyword">for</span> t=1:n-1, is=(1:k)+(t*k-k); J(:,:,is) = imtransform2(I(:,:,is), <span class="keyword">...</span>
0095     [],<span class="string">'vs'</span>,Vxs{t},<span class="string">'us'</span>,Vys{t},<span class="string">'pad'</span>,<span class="string">'replicate'</span>); <span class="keyword">end</span>
0096 <span class="keyword">if</span>(nargout&gt;1), Vxs=cell2array(Vxs); Vys=cell2array(Vys); <span class="keyword">end</span>
0097 
0098 <span class="keyword">end</span>
0099 
0100 <a name="_sub1" href="#_subfunctions" class="code">function [Vx,Vy] = interpolate( Vx, Vy, X, Y, type )</a>
0101 <span class="comment">% Interpolate flow fields at locations X,Y given flow fields Vx,Vy.</span>
0102 [h,w]=size(X); XY=@(X,Y) (min(max(X,1),w)-1)*h + min(max(Y,1),h);
0103 <span class="keyword">if</span>( type==1 )
0104   X=round(X); Y=round(Y); Z=XY(X,Y); Vx=Vx(Z); Vy=Vy(Z);
0105 <span class="keyword">else</span>
0106   Xd0=mod(X,1); Xd1=1-Xd0; Xi=X-Xd0;
0107   Yd0=mod(Y,1); Yd1=1-Yd0; Yi=Y-Yd0;
0108   W00=Xd1.*Yd1; W10=Xd0.*Yd1; W01=Xd1.*Yd0; W11=Xd0.*Yd0;
0109   Z00=XY(Xi,Yi); Z10=XY(Xi+1,Yi); Z01=XY(Xi,Yi+1); Z11=XY(Xi+1,Yi+1);
0110   Vx = W00.*Vx(Z00) + W10.*Vx(Z10) + W01.*Vx(Z01) + W11.*Vx(Z11);
0111   Vy = W00.*Vy(Z00) + W10.*Vy(Z10) + W01.*Vy(Z01) + W11.*Vy(Z11);
0112 <span class="keyword">end</span>
0113 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>