<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of opticalFlow</title>
  <meta name="keywords" content="opticalFlow">
  <meta name="description" content="Coarse-to-fine optical flow using Lucas&amp;Kanade or Horn&amp;Schunck.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">videos</a> &gt; opticalFlow.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\videos&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>opticalFlow
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Coarse-to-fine optical flow using Lucas&amp;Kanade or Horn&amp;Schunck.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [Vx,Vy,reliab] = opticalFlow( I1, I2, varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Coarse-to-fine optical flow using Lucas&amp;Kanade or Horn&amp;Schunck.

 Implemented 'type' of optical flow estimation:
  LK: http://en.wikipedia.org/wiki/Lucas-Kanade_method
  HS: http://en.wikipedia.org/wiki/Horn-Schunck_method
  SD: Simple block-based sum of absolute differences flow
 LK is a local, fast method (the implementation is fully vectorized).
 HS is a global, slower method (an SSE implementation is provided).
 SD is a simple but potentially expensive approach.

 Common parameters: 'smooth' determines smoothing prior to computing flow
 and can make flow estimation more robust. 'filt' determines amount of
 median filtering of the computed flow field which improves results but is
 costly. 'minScale' and 'maxScale' control image scales in the pyramid.
 Setting 'maxScale'&lt;1 results in faster but lower quality results, e.g.
 maxScale=.5 makes flow computation about 4x faster. Method specific
 parameters: 'radius' controls window size (and smoothness of flow) for LK
 and SD. 'nBlock' determines number of blocks tested in each direction for
 SD, computation time is O(nBlock^2). For HS, 'alpha' controls tradeoff
 between data and smoothness term (and smoothness of flow) and 'nIter'
 determines number of gradient decent steps.

 USAGE
  [Vx,Vy,reliab] = opticalFlow( I1, I2, pFlow )

 INPUTS
  I1, I2   - input images to calculate flow between
  pFlow    - parameters (struct or name/value pairs)
   .type       - ['LK'] may be 'LK', 'HS' or 'SD'
   .smooth     - [1] smoothing radius for triangle filter (may be 0)
   .filt       - [0] median filtering radius for smoothing flow field
   .minScale   - [1/64] minimum pyramid scale (must be a power of 2)
   .maxScale   - [1] maximum pyramid scale (must be a power of 2)
   .radius     - [10] integration radius for weighted window [LK/SD only]
   .nBlock     - [5] number of tested blocks [SD only]
   .alpha      - [1] smoothness constraint [HS only]
   .nIter      - [250] number of iterations [HS only]

 OUTPUTS
  Vx, Vy   - x,y components of flow  [Vx&gt;0-&gt;right, Vy&gt;0-&gt;down]
  reliab   - reliability of flow in given window

 EXAMPLE - compute LK flow on test images
  load opticalFlowTest;
  [Vx,Vy]=opticalFlow(I1,I2,'smooth',1,'radius',10,'type','LK');
  figure(1); im(I1); figure(2); im(I2);
  figure(3); im([Vx Vy]); colormap jet;

 EXAMPLE - rectify I1 to I2 using computed flow
  load opticalFlowTest;
  [Vx,Vy]=opticalFlow(I1,I2,'smooth',1,'radius',10,'type','LK');
  I1=imtransform2(I1,[],'vs',-Vx,'us',-Vy,'pad','replicate');
  figure(1); im(I1); figure(2); im(I2);

 EXAMPLE - compare LK/HS/SD flows
  load opticalFlowTest;
  prm={'smooth',1,'radius',10,'alpha',20,'nIter',250,'type'};
  tic, [Vx1,Vy1]=opticalFlow(I1,I2,prm{:},'LK'); toc
  tic, [Vx2,Vy2]=opticalFlow(I1,I2,prm{:},'HS'); toc
  tic, [Vx3,Vy3]=opticalFlow(I1,I2,prm{:},'SD','minScale',1); toc
  figure(1); im([Vx1 Vy1; Vx2 Vy2; Vx3 Vy3]); colormap jet;

 See also convTri, imtransform2, medfilt2

 Piotr's Computer Vision Matlab Toolbox      Version 3.50
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="imagesAlignSeq.html" class="code" title="function [J,Vxs,Vys] = imagesAlignSeq( I, pFlow, type, bndThr )">imagesAlignSeq</a>	Stabilize image sequence using coarse optical flow estimation.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Vx,Vy,reliab] = opticalFlowLk( I1, I2, radius  )</a></li><li><a href="#_sub2" class="code">function [Vx,Vy,reliab] = opticalFlowHs( I1, I2, alpha, nIter )</a></li><li><a href="#_sub3" class="code">function [Vx,Vy,reliab] = opticalFlowSd( I1, I2, radius, nBlock, step )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Vx,Vy,reliab] = opticalFlow( I1, I2, varargin )</a>
0002 <span class="comment">% Coarse-to-fine optical flow using Lucas&amp;Kanade or Horn&amp;Schunck.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Implemented 'type' of optical flow estimation:</span>
0005 <span class="comment">%  LK: http://en.wikipedia.org/wiki/Lucas-Kanade_method</span>
0006 <span class="comment">%  HS: http://en.wikipedia.org/wiki/Horn-Schunck_method</span>
0007 <span class="comment">%  SD: Simple block-based sum of absolute differences flow</span>
0008 <span class="comment">% LK is a local, fast method (the implementation is fully vectorized).</span>
0009 <span class="comment">% HS is a global, slower method (an SSE implementation is provided).</span>
0010 <span class="comment">% SD is a simple but potentially expensive approach.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Common parameters: 'smooth' determines smoothing prior to computing flow</span>
0013 <span class="comment">% and can make flow estimation more robust. 'filt' determines amount of</span>
0014 <span class="comment">% median filtering of the computed flow field which improves results but is</span>
0015 <span class="comment">% costly. 'minScale' and 'maxScale' control image scales in the pyramid.</span>
0016 <span class="comment">% Setting 'maxScale'&lt;1 results in faster but lower quality results, e.g.</span>
0017 <span class="comment">% maxScale=.5 makes flow computation about 4x faster. Method specific</span>
0018 <span class="comment">% parameters: 'radius' controls window size (and smoothness of flow) for LK</span>
0019 <span class="comment">% and SD. 'nBlock' determines number of blocks tested in each direction for</span>
0020 <span class="comment">% SD, computation time is O(nBlock^2). For HS, 'alpha' controls tradeoff</span>
0021 <span class="comment">% between data and smoothness term (and smoothness of flow) and 'nIter'</span>
0022 <span class="comment">% determines number of gradient decent steps.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% USAGE</span>
0025 <span class="comment">%  [Vx,Vy,reliab] = opticalFlow( I1, I2, pFlow )</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% INPUTS</span>
0028 <span class="comment">%  I1, I2   - input images to calculate flow between</span>
0029 <span class="comment">%  pFlow    - parameters (struct or name/value pairs)</span>
0030 <span class="comment">%   .type       - ['LK'] may be 'LK', 'HS' or 'SD'</span>
0031 <span class="comment">%   .smooth     - [1] smoothing radius for triangle filter (may be 0)</span>
0032 <span class="comment">%   .filt       - [0] median filtering radius for smoothing flow field</span>
0033 <span class="comment">%   .minScale   - [1/64] minimum pyramid scale (must be a power of 2)</span>
0034 <span class="comment">%   .maxScale   - [1] maximum pyramid scale (must be a power of 2)</span>
0035 <span class="comment">%   .radius     - [10] integration radius for weighted window [LK/SD only]</span>
0036 <span class="comment">%   .nBlock     - [5] number of tested blocks [SD only]</span>
0037 <span class="comment">%   .alpha      - [1] smoothness constraint [HS only]</span>
0038 <span class="comment">%   .nIter      - [250] number of iterations [HS only]</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% OUTPUTS</span>
0041 <span class="comment">%  Vx, Vy   - x,y components of flow  [Vx&gt;0-&gt;right, Vy&gt;0-&gt;down]</span>
0042 <span class="comment">%  reliab   - reliability of flow in given window</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% EXAMPLE - compute LK flow on test images</span>
0045 <span class="comment">%  load opticalFlowTest;</span>
0046 <span class="comment">%  [Vx,Vy]=opticalFlow(I1,I2,'smooth',1,'radius',10,'type','LK');</span>
0047 <span class="comment">%  figure(1); im(I1); figure(2); im(I2);</span>
0048 <span class="comment">%  figure(3); im([Vx Vy]); colormap jet;</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% EXAMPLE - rectify I1 to I2 using computed flow</span>
0051 <span class="comment">%  load opticalFlowTest;</span>
0052 <span class="comment">%  [Vx,Vy]=opticalFlow(I1,I2,'smooth',1,'radius',10,'type','LK');</span>
0053 <span class="comment">%  I1=imtransform2(I1,[],'vs',-Vx,'us',-Vy,'pad','replicate');</span>
0054 <span class="comment">%  figure(1); im(I1); figure(2); im(I2);</span>
0055 <span class="comment">%</span>
0056 <span class="comment">% EXAMPLE - compare LK/HS/SD flows</span>
0057 <span class="comment">%  load opticalFlowTest;</span>
0058 <span class="comment">%  prm={'smooth',1,'radius',10,'alpha',20,'nIter',250,'type'};</span>
0059 <span class="comment">%  tic, [Vx1,Vy1]=opticalFlow(I1,I2,prm{:},'LK'); toc</span>
0060 <span class="comment">%  tic, [Vx2,Vy2]=opticalFlow(I1,I2,prm{:},'HS'); toc</span>
0061 <span class="comment">%  tic, [Vx3,Vy3]=opticalFlow(I1,I2,prm{:},'SD','minScale',1); toc</span>
0062 <span class="comment">%  figure(1); im([Vx1 Vy1; Vx2 Vy2; Vx3 Vy3]); colormap jet;</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% See also convTri, imtransform2, medfilt2</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.50</span>
0067 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0068 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0069 
0070 <span class="comment">% get default parameters and do error checking</span>
0071 dfs={ <span class="string">'type'</span>,<span class="string">'LK'</span>, <span class="string">'smooth'</span>,1, <span class="string">'filt'</span>,0, <span class="string">'minScale'</span>,1/64, <span class="keyword">...</span>
0072   <span class="string">'maxScale'</span>,1, <span class="string">'radius'</span>,10, <span class="string">'nBlock'</span>,5, <span class="string">'alpha'</span>,1, <span class="string">'nIter'</span>,250 };
0073 [type,smooth,filt,minScale,maxScale,radius,nBlock,alpha,nIter] = <span class="keyword">...</span>
0074   getPrmDflt(varargin,dfs,1);
0075 assert(any(strcmp(type,{<span class="string">'LK'</span>,<span class="string">'HS'</span>,<span class="string">'SD'</span>})));
0076 <span class="keyword">if</span>( ~ismatrix(I1) || ~ismatrix(I2) || any(size(I1)~=size(I2)) )
0077   error(<span class="string">'Input images must be 2D and have same dimensions.'</span>); <span class="keyword">end</span>
0078 
0079 <span class="comment">% run optical flow in coarse to fine fashion</span>
0080 <span class="keyword">if</span>(~isa(I1,<span class="string">'single'</span>)), I1=single(I1); I2=single(I2); <span class="keyword">end</span>
0081 [h,w]=size(I1); nScales=max(1,floor(log2(min([h w 1/minScale])))+1);
0082 <span class="keyword">for</span> s=1:max(1,nScales + round(log2(maxScale)))
0083   <span class="comment">% get current scale and I1s and I2s at given scale</span>
0084   scale=2^(nScales-s); h1=round(h/scale); w1=round(w/scale);
0085   <span class="keyword">if</span>( scale==1 ), I1s=I1; I2s=I2; <span class="keyword">else</span>
0086     I1s=imResample(I1,[h1 w1]); I2s=imResample(I2,[h1 w1]); <span class="keyword">end</span>
0087   <span class="comment">% initialize Vx,Vy or upsample from previous scale</span>
0088   <span class="keyword">if</span>(s==1), Vx=zeros(h1,w1,<span class="string">'single'</span>); Vy=Vx; <span class="keyword">else</span> r=sqrt(h1*w1/numel(Vx));
0089     Vx=imResample(Vx,[h1 w1])*r; Vy=imResample(Vy,[h1 w1])*r; <span class="keyword">end</span>
0090   <span class="comment">% transform I2s according to current estimate of Vx and Vy</span>
0091   <span class="keyword">if</span>(s&gt;1), I2s=imtransform2(I2s,[],<span class="string">'pad'</span>,<span class="string">'replciate'</span>,<span class="string">'vs'</span>,Vx,<span class="string">'us'</span>,Vy); <span class="keyword">end</span>
0092   <span class="comment">% smooth images</span>
0093   I1s=convTri(I1s,smooth); I2s=convTri(I2s,smooth);
0094   <span class="comment">% run optical flow on current scale</span>
0095   <span class="keyword">switch</span> type
0096     <span class="keyword">case</span> <span class="string">'LK'</span>, [Vx1,Vy1,reliab]=<a href="#_sub1" class="code" title="subfunction [Vx,Vy,reliab] = opticalFlowLk( I1, I2, radius  )">opticalFlowLk</a>(I1s,I2s,radius);
0097     <span class="keyword">case</span> <span class="string">'HS'</span>, [Vx1,Vy1,reliab]=<a href="#_sub2" class="code" title="subfunction [Vx,Vy,reliab] = opticalFlowHs( I1, I2, alpha, nIter )">opticalFlowHs</a>(I1s,I2s,alpha,nIter);
0098     <span class="keyword">case</span> <span class="string">'SD'</span>, [Vx1,Vy1,reliab]=<a href="#_sub3" class="code" title="subfunction [Vx,Vy,reliab] = opticalFlowSd( I1, I2, radius, nBlock, step )">opticalFlowSd</a>(I1s,I2s,radius,nBlock,1);
0099   <span class="keyword">end</span>
0100   Vx=Vx+Vx1; Vy=Vy+Vy1;
0101   <span class="comment">% finally median filter the resulting flow field</span>
0102   <span class="keyword">if</span>(filt), Vx=medfilt2(Vx,[filt filt],<span class="string">'symmetric'</span>); <span class="keyword">end</span>
0103   <span class="keyword">if</span>(filt), Vy=medfilt2(Vy,[filt filt],<span class="string">'symmetric'</span>); <span class="keyword">end</span>
0104 <span class="keyword">end</span>
0105 r=sqrt(h*w/numel(Vx));
0106 <span class="keyword">if</span>(r~=1), Vx=imResample(Vx,[h w])*r; Vy=imResample(Vy,[h w])*r; <span class="keyword">end</span>
0107 <span class="keyword">if</span>(r~=1 &amp;&amp; nargout==3), reliab=imResample(reliab,[h w]); <span class="keyword">end</span>
0108 
0109 <span class="keyword">end</span>
0110 
0111 <a name="_sub1" href="#_subfunctions" class="code">function [Vx,Vy,reliab] = opticalFlowLk( I1, I2, radius  )</a>
0112 <span class="comment">% Compute elements of A'A and also of A'b</span>
0113 radius=min(radius,floor(min(size(I1,1),size(I1,2))/2)-1);
0114 [Ix,Iy]=gradient2(I1); It=I2-I1; AAxy=convTri(Ix.*Iy,radius);
0115 AAxx=convTri(Ix.^2,radius)+1e-5; ABxt=convTri(-Ix.*It,radius);
0116 AAyy=convTri(Iy.^2,radius)+1e-5; AByt=convTri(-Iy.*It,radius);
0117 <span class="comment">% Find determinant and trace of A'A</span>
0118 AAdet=AAxx.*AAyy-AAxy.^2; AAdeti=1./AAdet;
0119 AAdeti(isinf(AAdeti))=0; AAtr=AAxx+AAyy;
0120 <span class="comment">% Compute components of velocity vectors (A'A)^-1 * A'b</span>
0121 Vx = AAdeti .* ( AAyy.*ABxt - AAxy.*AByt);
0122 Vy = AAdeti .* (-AAxy.*ABxt + AAxx.*AByt);
0123 <span class="comment">% Check for ill conditioned second moment matrices</span>
0124 reliab = 0.5*AAtr - 0.5*sqrt(AAtr.^2-4*AAdet);
0125 <span class="keyword">end</span>
0126 
0127 <a name="_sub2" href="#_subfunctions" class="code">function [Vx,Vy,reliab] = opticalFlowHs( I1, I2, alpha, nIter )</a>
0128 <span class="comment">% compute derivatives (averaging over 2x2 neighborhoods)</span>
0129 pad = @(I,p) imPad(I,p,<span class="string">'replicate'</span>);
0130 crop = @(I,c) I(1+c:end-c,1+c:end-c);
0131 Ex = I1(:,2:end)-I1(:,1:end-1) + I2(:,2:end)-I2(:,1:end-1);
0132 Ey = I1(2:<span class="keyword">end</span>,:)-I1(1:end-1,:) + I2(2:<span class="keyword">end</span>,:)-I2(1:end-1,:);
0133 Ex = Ex/4; Ey = Ey/4; Et = (I2-I1)/4;
0134 Ex = pad(Ex,[1 1 1 2]) + pad(Ex,[0 2 1 2]);
0135 Ey = pad(Ey,[1 2 1 1]) + pad(Ey,[1 2 0 2]);
0136 Et=pad(Et,[0 2 1 1])+pad(Et,[1 1 1 1])+pad(Et,[1 1 0 2])+pad(Et,[0 2 0 2]);
0137 Z=1./(alpha*alpha + Ex.*Ex + Ey.*Ey); reliab=crop(Z,1);
0138 <span class="comment">% iterate updating Ux and Vx in each iter</span>
0139 <span class="keyword">if</span>( 1 )
0140   [Vx,Vy]=opticalFlowHsMex(Ex,Ey,Et,Z,nIter);
0141   Vx=crop(Vx,1); Vy=crop(Vy,1);
0142 <span class="keyword">else</span>
0143   Ex=crop(Ex,1); Ey=crop(Ey,1); Et=crop(Et,1); Z=crop(Z,1);
0144   Vx=zeros(size(I1),<span class="string">'single'</span>); Vy=Vx;
0145   f=single([0 1 0; 1 0 1; 0 1 0])/4;
0146   <span class="keyword">for</span> i = 1:nIter
0147     Mx=conv2(Vx,f,<span class="string">'same'</span>); My=conv2(Vy,f,<span class="string">'same'</span>);
0148     m=(Ex.*Mx+Ey.*My+Et).*Z; Vx=Mx-Ex.*m; Vy=My-Ey.*m;
0149   <span class="keyword">end</span>
0150 <span class="keyword">end</span>
0151 <span class="keyword">end</span>
0152 
0153 <a name="_sub3" href="#_subfunctions" class="code">function [Vx,Vy,reliab] = opticalFlowSd( I1, I2, radius, nBlock, step )</a>
0154 <span class="comment">% simple block-based sum of absolute differences flow</span>
0155 [h,w]=size(I1); k=2*nBlock+1; k=k*k; D=zeros(h,w,k,<span class="string">'single'</span>); k=1;
0156 rng = @(x,w) max(1+x*step,1):min(w+x*step,w);
0157 <span class="keyword">for</span> x=-nBlock:nBlock, xs0=rng(x,w); xs1=rng(-x,w);
0158   <span class="keyword">for</span> y=-nBlock:nBlock, ys0=rng(y,h); ys1=rng(-y,h);
0159     D(ys0,xs0,k)=abs(I1(ys0,xs0)-I2(ys1,xs1)); k=k+1;
0160   <span class="keyword">end</span>
0161 <span class="keyword">end</span>
0162 D=convTri(D,radius); [reliab,D]=min(D,[],3);
0163 k=2*nBlock+1; Vy=mod(D-1,k)+1; Vx=(D-Vy)/k+1;
0164 Vy=(nBlock+1-Vy)*step; Vx=(nBlock+1-Vx)*step;
0165 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>