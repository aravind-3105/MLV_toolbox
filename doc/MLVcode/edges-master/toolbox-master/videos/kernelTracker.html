<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of kernelTracker</title>
  <meta name="keywords" content="kernelTracker">
  <meta name="description" content="Kernel Tracker from Comaniciu, Ramesh and Meer PAMI 2003.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">videos</a> &gt; kernelTracker.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\videos&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>kernelTracker
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Kernel Tracker from Comaniciu, Ramesh and Meer PAMI 2003.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [allRct, allSim, allIc] = kernelTracker( I, prm ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Kernel Tracker from Comaniciu, Ramesh and Meer PAMI 2003.

 Implements the algorithm described in &quot;Kernel-Based Object Tracking&quot; by
 Dorin Comaniciu, Visvanathan Ramesh and Peter Meer, PAMI 25, 564-577,
 2003.  This is a fast tracking algorithm that utilizes a histogram
 representation of an object (in this implementation we use color
 histograms, as in the original work).  The idea is given a histogram q in
 frame t, find histogram p in frame t+1 that is most similar to q. It
 turns out that this can be formulated as a mean shift problem. Here, the
 kernel is fixed to the Epanechnikov kernel.

 This implementation uses mex files to optimize speed, it is significantly
 faster than  real time for a single object on a 2GHz standard laptop (as
 of 2007).

 If I==[], toy data is created.  If rctS==0, the user is queried to
 specify the first rectangle.  rctE, denoting the object location in the
 last frame, can optionally be specified.  If rctE is given, the model
 histogram at fraction r of the video is (1-r)*histS+r*histE where histS
 and histE are the model histograms from the first and last frame.  If
 rctE==0 rectangle in final frame is queried, if rectE==-1 it is not used.

 Let T denote the length of the video. Returned values are of length t,
 where t==T if the object was tracked through the whole sequence (ie sim
 does not fall below simThr), otherwise t&lt;=T is equal to the last frame in
 which obj was found.  You can test if the object was tracked using:
   success = (size(allRct,1)==size(I,4));

 USAGE
  [allRct, allIc, allSim] = kernelTracker( [I], [prm] )

 INPUTS
  I            - MxNx3xT input video
  [prm]
   .rctS       - [0] rectangle denoting initial object location
   .rctE       - [-1] rectangle denoting final object location
   .dispFlag   - [1] show interactive display
   .scaleSrch  - [1] if true search over scale
   .nBit       - [4] n=2^nBit, color histograms are [n x n x n]
   .simThr     - [.7] sim thr for when obj is considered lost
   .scaleDel   - [.9] multiplicative diff between consecutive scales

 OUTPUTS
  allRct       - [t x 4] array of t locations [x,y,wd,ht]
  allSim       - [1 x t] array of similarity measures during tracking
  allIc        - [1 x t] cell array of cropped windows containing obj

 EXAMPLE
  disp('Select a rectangular region for tracking');
  [allRct,allSim,allIc] = kernelTracker();
  figure(2); clf; plot(allRct);
  figure(3); clf; montage2(allIc,struct('hasChn',true));

 See also

 Piotr's Computer Vision Matlab Toolbox      Version 3.22
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [p,pos,Ic,sim] = kernelTracker1( I, q, pos, kernel, nBit )</a></li><li><a href="#_sub2" class="code">function kernel = buildKernel( wd, ht )</a></li><li><a href="#_sub3" class="code">function p = buildHist( Qc, kernel, nBit )</a></li><li><a href="#_sub4" class="code">function [Ic,Qc] = cropWindow( I, nBit, pos, wd, ht )</a></li><li><a href="#_sub5" class="code">function I = toyData( n, sigma )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [allRct, allSim, allIc] = kernelTracker( I, prm )</a>
0002 <span class="comment">% Kernel Tracker from Comaniciu, Ramesh and Meer PAMI 2003.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Implements the algorithm described in &quot;Kernel-Based Object Tracking&quot; by</span>
0005 <span class="comment">% Dorin Comaniciu, Visvanathan Ramesh and Peter Meer, PAMI 25, 564-577,</span>
0006 <span class="comment">% 2003.  This is a fast tracking algorithm that utilizes a histogram</span>
0007 <span class="comment">% representation of an object (in this implementation we use color</span>
0008 <span class="comment">% histograms, as in the original work).  The idea is given a histogram q in</span>
0009 <span class="comment">% frame t, find histogram p in frame t+1 that is most similar to q. It</span>
0010 <span class="comment">% turns out that this can be formulated as a mean shift problem. Here, the</span>
0011 <span class="comment">% kernel is fixed to the Epanechnikov kernel.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% This implementation uses mex files to optimize speed, it is significantly</span>
0014 <span class="comment">% faster than  real time for a single object on a 2GHz standard laptop (as</span>
0015 <span class="comment">% of 2007).</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% If I==[], toy data is created.  If rctS==0, the user is queried to</span>
0018 <span class="comment">% specify the first rectangle.  rctE, denoting the object location in the</span>
0019 <span class="comment">% last frame, can optionally be specified.  If rctE is given, the model</span>
0020 <span class="comment">% histogram at fraction r of the video is (1-r)*histS+r*histE where histS</span>
0021 <span class="comment">% and histE are the model histograms from the first and last frame.  If</span>
0022 <span class="comment">% rctE==0 rectangle in final frame is queried, if rectE==-1 it is not used.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Let T denote the length of the video. Returned values are of length t,</span>
0025 <span class="comment">% where t==T if the object was tracked through the whole sequence (ie sim</span>
0026 <span class="comment">% does not fall below simThr), otherwise t&lt;=T is equal to the last frame in</span>
0027 <span class="comment">% which obj was found.  You can test if the object was tracked using:</span>
0028 <span class="comment">%   success = (size(allRct,1)==size(I,4));</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% USAGE</span>
0031 <span class="comment">%  [allRct, allIc, allSim] = kernelTracker( [I], [prm] )</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% INPUTS</span>
0034 <span class="comment">%  I            - MxNx3xT input video</span>
0035 <span class="comment">%  [prm]</span>
0036 <span class="comment">%   .rctS       - [0] rectangle denoting initial object location</span>
0037 <span class="comment">%   .rctE       - [-1] rectangle denoting final object location</span>
0038 <span class="comment">%   .dispFlag   - [1] show interactive display</span>
0039 <span class="comment">%   .scaleSrch  - [1] if true search over scale</span>
0040 <span class="comment">%   .nBit       - [4] n=2^nBit, color histograms are [n x n x n]</span>
0041 <span class="comment">%   .simThr     - [.7] sim thr for when obj is considered lost</span>
0042 <span class="comment">%   .scaleDel   - [.9] multiplicative diff between consecutive scales</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% OUTPUTS</span>
0045 <span class="comment">%  allRct       - [t x 4] array of t locations [x,y,wd,ht]</span>
0046 <span class="comment">%  allSim       - [1 x t] array of similarity measures during tracking</span>
0047 <span class="comment">%  allIc        - [1 x t] cell array of cropped windows containing obj</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% EXAMPLE</span>
0050 <span class="comment">%  disp('Select a rectangular region for tracking');</span>
0051 <span class="comment">%  [allRct,allSim,allIc] = kernelTracker();</span>
0052 <span class="comment">%  figure(2); clf; plot(allRct);</span>
0053 <span class="comment">%  figure(3); clf; montage2(allIc,struct('hasChn',true));</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% See also</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.22</span>
0058 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0059 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0060 
0061 <span class="comment">%%% get parameters (set defaults)</span>
0062 <span class="keyword">if</span>( nargin&lt;1 ); I=[]; <span class="keyword">end</span>;
0063 <span class="keyword">if</span>( nargin&lt;2 ); prm=struct(); <span class="keyword">end</span>;
0064 dfs = {<span class="string">'scaleSrch'</span>,1, <span class="string">'nBit'</span>,4, <span class="string">'simThr'</span>,.7, <span class="keyword">...</span>
0065   <span class="string">'dispFlag'</span>,1, <span class="string">'scaleDel'</span>,.9, <span class="string">'rctS'</span>,0, <span class="string">'rctE'</span>,-1 };
0066 prm = getPrmDflt( prm, dfs );
0067 scaleSrch=prm.scaleSrch; nBit=prm.nBit; simThr=prm.simThr;
0068 dispFlag=prm.dispFlag; scaleDel=prm.scaleDel;
0069 rctS=prm.rctS; rctE=prm.rctE;
0070 <span class="keyword">if</span>(isempty(I)); I=<a href="#_sub5" class="code" title="subfunction I = toyData( n, sigma )">toyData</a>(100,1); <span class="keyword">end</span>;
0071 
0072 <span class="comment">%%% get rctS and rectE if necessary</span>
0073 rctProp = {<span class="string">'EdgeColor'</span>,<span class="string">'g'</span>,<span class="string">'Curvature'</span>,[1 1],<span class="string">'LineWidth'</span>,2};
0074 <span class="keyword">if</span>(rctS==0); figure(1); clf; imshow(I(:,:,:,1)); rctS=getrect; <span class="keyword">end</span>
0075 <span class="keyword">if</span>(rctE==0); figure(1); clf; imshow(I(:,:,:,end)); rctE=getrect; <span class="keyword">end</span>
0076 
0077 <span class="comment">%%% precompute kernels for all relevant scales</span>
0078 rctS=round(rctS); rctS(3:4)=rctS(3:4)-mod(rctS(3:4),2);
0079 pos1 = rctS(1:2)+rctS(3:4)/2;  wd=rctS(3);  ht=rctS(4);
0080 [mRows,nCols,~,nFrame] = size(I);
0081 nScaleSm = max(1,floor(log(max(10/wd,10/ht))/log(scaleDel)));
0082 nScaleLr = max(1,floor(-log(min(nCols/wd,mRows/ht)/2)/log(scaleDel)));
0083 nScale = nScaleSm+nScaleLr+1;  scale = nScaleSm+1;
0084 kernel = repmat( <a href="#_sub2" class="code" title="subfunction kernel = buildKernel( wd, ht )">buildKernel</a>(wd,ht), [1 nScale] );
0085 <span class="keyword">for</span> s=1:nScale
0086   r = power(scaleDel,s-1-nScaleSm);
0087   kernel(s) = <a href="#_sub2" class="code" title="subfunction kernel = buildKernel( wd, ht )">buildKernel</a>( wd/r, ht/r );
0088 <span class="keyword">end</span>
0089 
0090 <span class="comment">%%% build model histogram for rctS</span>
0091 [Ic,Qc] = <a href="#_sub4" class="code" title="subfunction [Ic,Qc] = cropWindow( I, nBit, pos, wd, ht )">cropWindow</a>( I(:,:,:,1), nBit, pos1, wd, ht );
0092 qS = <a href="#_sub3" class="code" title="subfunction p = buildHist( Qc, kernel, nBit )">buildHist</a>( Qc, kernel(scale), nBit );
0093 
0094 <span class="comment">%%% optionally build model histogram for rctE</span>
0095 <span class="keyword">if</span>(length(rctE)==4);
0096   rctE=round(rctE); rctE(3:4)=rctE(3:4)-mod(rctE(3:4),2);
0097   posE = rctE(1:2)+rctE(3:4)/2; wdE=rctE(3);  htE=rctE(4);
0098   kernelE = <a href="#_sub2" class="code" title="subfunction kernel = buildKernel( wd, ht )">buildKernel</a>(wdE,htE);
0099   [Ic,Qc] = <a href="#_sub4" class="code" title="subfunction [Ic,Qc] = cropWindow( I, nBit, pos, wd, ht )">cropWindow</a>( I(:,:,:,end), nBit, posE, wdE, htE ); <span class="comment">%end</span>
0100   qE = <a href="#_sub3" class="code" title="subfunction p = buildHist( Qc, kernel, nBit )">buildHist</a>( Qc, kernelE, nBit );
0101 <span class="keyword">else</span>
0102   qE = qS;
0103 <span class="keyword">end</span>
0104 
0105 <span class="comment">%%% setup display</span>
0106 <span class="keyword">if</span>( dispFlag )
0107   figure(1); clf; hImg=imshow(I(:,:,:,1));
0108   hR = rectangle(<span class="string">'Position'</span>, rctS, rctProp{:} );
0109   pause(.1);
0110 <span class="keyword">end</span>
0111 
0112 <span class="comment">%%% main loop</span>
0113 pos = pos1;
0114 allRct = zeros(nFrame,4); allRct(1,:)=rctS;
0115 allIc = cell(1,nFrame); allIc{1}=Ic;
0116 allSim = zeros(1,nFrame);
0117 <span class="keyword">for</span> frm = 1:nFrame
0118   Icur = I(:,:,:,frm);
0119   
0120   <span class="comment">% current model (linearly interpolate)</span>
0121   r=(frm-1)/nFrame; q = qS*(1-r) + qE*r;
0122   
0123   <span class="keyword">if</span>( scaleSrch )
0124     <span class="comment">% search over scale</span>
0125     best={}; bestSim=-1; pos1=pos;
0126     <span class="keyword">for</span> s=max(1,scale-1):min(nScale,scale+1)
0127       [p,pos,Ic,sim]=<a href="#_sub1" class="code" title="subfunction [p,pos,Ic,sim] = kernelTracker1( I, q, pos, kernel, nBit )">kernelTracker1</a>(Icur,q,pos1,kernel(s),nBit);
0128       <span class="keyword">if</span>( sim&gt;bestSim ); best={p,pos,Ic,s}; bestSim=sim; <span class="keyword">end</span>;
0129     <span class="keyword">end</span>
0130     [~,pos,Ic,scale]=deal(best{:});
0131     wd=kernel(scale).wd; ht=kernel(scale).ht;
0132     
0133   <span class="keyword">else</span>
0134     <span class="comment">% otherwise just do meanshift once</span>
0135     [~,pos,Ic,bestSim]=<a href="#_sub1" class="code" title="subfunction [p,pos,Ic,sim] = kernelTracker1( I, q, pos, kernel, nBit )">kernelTracker1</a>(Icur,q,pos,kernel(scale),nBit);
0136   <span class="keyword">end</span>
0137   
0138   <span class="comment">% record results</span>
0139   <span class="keyword">if</span>( bestSim&lt;simThr ); <span class="keyword">break</span>; <span class="keyword">end</span>;
0140   rctC=[pos(1)-wd/2 pos(2)-ht/2 wd, ht ];
0141   allIc{frm}=Ic;  allRct(frm,:)=rctC;
0142   allSim(frm)=bestSim;
0143   
0144   <span class="comment">% display</span>
0145   <span class="keyword">if</span>( dispFlag )
0146     set(hImg,<span class="string">'CData'</span>,Icur); title([<span class="string">'bestSim='</span> num2str(bestSim)]);
0147     delete(hR); hR=rectangle(<span class="string">'Position'</span>, rctC, rctProp{:} );
0148     <span class="keyword">if</span>(0); waitforbuttonpress; <span class="keyword">else</span> drawnow; <span class="keyword">end</span>
0149   <span class="keyword">end</span>
0150 <span class="keyword">end</span>
0151 
0152 <span class="comment">%%% finalize &amp; display</span>
0153 <span class="keyword">if</span>( bestSim&lt;simThr ); frm=frm-1; <span class="keyword">end</span>;
0154 allIc=allIc(1:frm); allRct=allRct(1:frm,:); allSim=allSim(1:frm);
0155 <span class="keyword">if</span>( dispFlag )
0156   <span class="keyword">if</span>( bestSim&lt;simThr ); disp(<span class="string">'lost target'</span>); <span class="keyword">end</span>
0157   disp( [<span class="string">'final sim = '</span> num2str(bestSim) ] );
0158 <span class="keyword">end</span>
0159 
0160 <span class="keyword">end</span>
0161 
0162 <a name="_sub1" href="#_subfunctions" class="code">function [p,pos,Ic,sim] = kernelTracker1( I, q, pos, kernel, nBit )</a>
0163 
0164 mRows=size(I,1); nCols=size(I,2);
0165 wd=kernel.wd; wd2=wd/2;
0166 ht=kernel.ht; ht2=ht/2;
0167 xs=kernel.xs; ys=kernel.ys;
0168 <span class="keyword">for</span> iter=1:1000
0169   posPrev = pos;
0170   
0171   <span class="comment">% check if pos in bounds</span>
0172   rct = [pos(1)-wd/2 pos(2)-ht/2 wd, ht ];
0173   <span class="keyword">if</span>( rct(1)&lt;1 || rct(2)&lt;1 || (rct(1)+wd)&gt;nCols || (rct(2)+ht)&gt;mRows )
0174     pos=posPrev; p=[]; Ic=[]; sim=eps; <span class="keyword">return</span>;
0175   <span class="keyword">end</span>
0176   
0177   <span class="comment">% crop window / compute histogram</span>
0178   [Ic,Qc] = <a href="#_sub4" class="code" title="subfunction [Ic,Qc] = cropWindow( I, nBit, pos, wd, ht )">cropWindow</a>( I, nBit, pos, wd, ht );
0179   p = <a href="#_sub3" class="code" title="subfunction p = buildHist( Qc, kernel, nBit )">buildHist</a>( Qc, kernel, nBit );
0180   <span class="keyword">if</span>( iter==20 ); <span class="keyword">break</span>; <span class="keyword">end</span>;
0181   
0182   <span class="comment">% compute meanshift step</span>
0183   w = ktComputeW_c( Qc, q, p, nBit );
0184   posDel = [sum(xs.*w)*wd2, sum(ys.*w)*ht2] / (sum(w)+eps);
0185   posDel = round(posDel+.1);
0186   <span class="keyword">if</span>(all(posDel==0)); <span class="keyword">break</span>; <span class="keyword">end</span>;
0187   pos = pos + posDel;
0188 <span class="keyword">end</span>
0189 locs=p&gt;0; sim=sum( sqrt(q(locs).*p(locs)) );
0190 <span class="keyword">end</span>
0191 
0192 <a name="_sub2" href="#_subfunctions" class="code">function kernel = buildKernel( wd, ht )</a>
0193 wd = round(wd/2)*2;  xs = linspace(-1,1,wd);
0194 ht = round(ht/2)*2;  ys = linspace(-1,1,ht);
0195 [ys,xs] = ndgrid(ys,xs); xs=xs(:); ys=ys(:);
0196 xMag = ys.*ys + xs.*xs;  xMag(xMag&gt;1) = 1;
0197 K = 2/pi * (1-xMag);  sumK=sum(K);
0198 kernel = struct( <span class="string">'K'</span>,K, <span class="string">'sumK'</span>,sumK, <span class="string">'xs'</span>,xs, <span class="string">'ys'</span>,ys, <span class="string">'wd'</span>,wd, <span class="string">'ht'</span>,ht );
0199 <span class="keyword">end</span>
0200 
0201 <a name="_sub3" href="#_subfunctions" class="code">function p = buildHist( Qc, kernel, nBit )</a>
0202 p = ktHistcRgb_c( Qc, kernel.K, nBit ) / kernel.sumK;
0203 <span class="keyword">if</span>(0); p=gaussSmooth(p,.5,<span class="string">'same'</span>,2); p=p*(1/sum(p(:))); <span class="keyword">end</span>;
0204 <span class="keyword">end</span>
0205 
0206 <a name="_sub4" href="#_subfunctions" class="code">function [Ic,Qc] = cropWindow( I, nBit, pos, wd, ht )</a>
0207 row = pos(2)-ht/2;  col = pos(1)-wd/2;
0208 Ic = I(row:row+ht-1,col:col+wd-1,:);
0209 <span class="keyword">if</span>(nargout==2); Qc=bitshift(reshape(Ic,[],3),nBit-8); <span class="keyword">end</span>;
0210 <span class="keyword">end</span>
0211 
0212 <a name="_sub5" href="#_subfunctions" class="code">function I = toyData( n, sigma )</a>
0213 I1 = imresize(imread(<span class="string">'peppers.png'</span>),[256 256],<span class="string">'bilinear'</span>);
0214 I=ones(512,512,3,n,<span class="string">'uint8'</span>)*100;
0215 pos = round(gaussSmooth(randn(2,n)*80,[0 4]))+128;
0216 <span class="keyword">for</span> i=1:n
0217   I((1:256)+pos(1,i),(1:256)+pos(2,i),:,i)=I1;
0218   I1 = uint8(double(I1) + randn(size(I1))*sigma);
0219 <span class="keyword">end</span>;
0220 I=I((1:256)+128,(1:256)+128,:,:);
0221 <span class="keyword">end</span>
0222 
0223 <span class="comment">% % debugging code</span>
0224 <span class="comment">% if( debug )</span>
0225 <span class="comment">%   figure(1);</span>
0226 <span class="comment">%   subplot(2,3,2); image( Ic ); subplot(2,3,1); image(Icur);</span>
0227 <span class="comment">%   rectangle('Position', posToRct(pos0,wd,ht), rctProp{:} );</span>
0228 <span class="comment">%   subplot(2,3,3); imagesc( reshape(w,wd,ht), [0 5] ); colormap gray;</span>
0229 <span class="comment">%   subplot(2,3,4); montage2( q ); subplot(2,3,5); montage2( p1 );</span>
0230 <span class="comment">%   waitforbuttonpress;</span>
0231 <span class="comment">% end</span>
0232 
0233 <span class="comment">% % search over 9 locations (with fixed scale)</span>
0234 <span class="comment">% if( locSrch )</span>
0235 <span class="comment">%   best={};  bestSim=0.0;  pos1=pos;</span>
0236 <span class="comment">%   for lr=-1:1</span>
0237 <span class="comment">%     for ud=-1:1</span>
0238 <span class="comment">%       posSt = pos1 + [wd*lr ht*ud];</span>
0239 <span class="comment">%       [p,pos,Ic,sim] = kernelTracker1(Icur,q,posSt,kernel(scale),nBit);</span>
0240 <span class="comment">%       if( sim&gt;bestSim ); best={p,pos,Ic}; bestSim=sim; end;</span>
0241 <span class="comment">%     end</span>
0242 <span class="comment">%   end</span>
0243 <span class="comment">%   [p,pos,Ic]=deal(best{:});</span>
0244 <span class="comment">% end</span>
0245 
0246 <span class="comment">%%% background histogram -- seems kind of useless, removed</span>
0247 <span class="comment">% if( 0 )</span>
0248 <span class="comment">%   bgSiz = 3; bgImp = 2;</span>
0249 <span class="comment">%   rctBgStr = max([1 1],rctS(1:2)-rctS(3:4)*(bgSiz/2-.5));</span>
0250 <span class="comment">%   rctBgEnd = min([nCols mRows],rctS(1:2)+rctS(3:4)*(bgSiz/2+.5));</span>
0251 <span class="comment">%   rctBg = [rctBgStr rctBgEnd-rctBgStr+1];</span>
0252 <span class="comment">%   posBg = rctBg(1:2)+rctBg(3:4)/2;  wdBg=rctBg(3);  htBg=rctBg(4);</span>
0253 <span class="comment">%   [IcBg,QcBg] = cropWindow( I(:,:,:,1), nBit, posBg, wdBg, htBg );</span>
0254 <span class="comment">%   wtBg = double( reshape(kernel.K,ht,wd)==0 );</span>
0255 <span class="comment">%   pre=rctS(1:2)-rctBg(1:2);  pst=rctBg(3:4)-rctS(3:4)-pre;</span>
0256 <span class="comment">%   wtBg = padarray( wtBg, fliplr(pre), 1, 'pre' );</span>
0257 <span class="comment">%   wtBg = padarray( wtBg, fliplr(pst), 1, 'post' );</span>
0258 <span class="comment">%   pBg = buildHist( QcBg, wtBg, [], nBit );</span>
0259 <span class="comment">%   pWts = min( 1, max(pBg(:))/bgImp./pBg );</span>
0260 <span class="comment">%   if(0); montage2(pWts); impixelinfo; return; end</span>
0261 <span class="comment">% else</span>
0262 <span class="comment">%   pWts=[];</span>
0263 <span class="comment">% end;</span>
0264 <span class="comment">% if(~isempty(pWts)); p = p .* pWts; end; % in buildHistogram</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>