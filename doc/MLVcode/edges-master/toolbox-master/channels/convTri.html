<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of convTri</title>
  <meta name="keywords" content="convTri">
  <meta name="description" content="Extremely fast 2D image convolution with a triangle filter.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; convTri.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>convTri
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Extremely fast 2D image convolution with a triangle filter.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function J = convTri( I, r, s, nomex ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Extremely fast 2D image convolution with a triangle filter.

 Convolves an image by a 2D triangle filter (the 1D triangle filter f is
 [1:r r+1 r:-1:1]/(r+1)^2, the 2D version is simply conv2(f,f')). The
 convolution can be performed in constant time per-pixel, independent of
 the radius r. In fact the implementation is nearly optimal, with the
 convolution taking only slightly more time than creating a copy of the
 input array. Boundary effects are handled as if the image were padded
 symmetrically prior to performing the convolution. An optional integer
 downsampling parameter &quot;s&quot; can be specified, in which case the output is
 downsampled by s (the implementation is efficient with downsampling
 occurring simultaneously with smoothing, saving additional time).

 The output is exactly equivalent to the following Matlab operations:
  f = [1:r r+1 r:-1:1]/(r+1)^2;
  J = padarray(I,[r r],'symmetric','both');
  J = convn(convn(J,f,'valid'),f','valid');
  if(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); end
 The computation, however, is an order of magnitude faster than the above.

 When used as a smoothing filter, the standard deviation (sigma) of a tri
 filter with radius r can be computed using [sigma=sqrt(r*(r+2)/6)]. For
 the first few values of r this translates to: r=1: sigma=1/sqrt(2), r=2:
 sigma=sqrt(4/3), r=3: sqrt(5/2), r=4: sigma=2. Given sigma, the
 equivalent value of r can be computed via [r=sqrt(6*sigma*sigma+1)-1].

 For even finer grained control for very small amounts of smoothing, any
 value of r between 0 and 1 can be used (normally if r&gt;=1 then r must be
 an integer). In this case a filter of the form fp=[1 p 1]/(2+p) is used,
 with p being determined automatically from r. The filter fp has a
 standard deviation of [sigma=sqrt(2/(p+2))]. Hence p can be determined
 from r by setting [sqrt(r*(r+2)/6)=sqrt(2/(p+2))], which gives
 [p=12/r/(r+2)-2]. Note that r=1 gives p=2, so fp=[1 2 1]/4 which is the
 same as the normal r=1 triangle filter. As r goes to 0, p goes to
 infinity, and fp becomes the delta function [0 1 0]. The computation for
 r&lt;=1 is particularly fast.

 The related function convBox performs convolution with a box filter,
 which is slightly faster but has worse properties if used for smoothing.

 This code requires SSE2 to compile and run (most modern Intel and AMD
 processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.

 USAGE
  J = convTri( I, r, [s], [nomex] )

 INPUTS
  I      - [hxwxk] input k channel single image
  r      - integer filter radius (or any value between 0 and 1)
           filter standard deviation is: sigma=sqrt(r*(r+2)/6)
  s      - [1] integer downsampling amount after convolving
  nomex  - [0] if true perform computation in matlab (for testing/timing)

 OUTPUTS
  J      - [hxwxk] smoothed image

 EXAMPLE - matlab versus mex
  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;
  r = 5; s = 2; % set parameters as desired
  tic, J1=convTri(I,r,s); toc % mex version (fast)
  tic, J2=convTri(I,r,s,1); toc % matlab version (slow)
  figure(1); im(J1); figure(2); im(abs(J2-J1));

 EXAMPLE - triangle versus gaussian smoothing
  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;
  sigma = 4; rg = ceil(3*sigma); f = filterGauss(2*rg+1,[],sigma^2);
  tic, J1=conv2(conv2(imPad(I,rg,'symmetric'),f,'valid'),f','valid'); toc
  r=sqrt(6*sigma*sigma+1)-1; tic, J2=convTri(I,r); toc
  figure(1); im(J1); figure(2); im(J2); figure(3); im(abs(J2-J1));

 See also conv2, <a href="convBox.html" class="code" title="function J = convBox( I, r, s, nomex )">convBox</a>, gaussSmooth

 Piotr's Computer Vision Matlab Toolbox      Version 3.02
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>	Compute channel features at a single scale given an input image.</li><li><a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>	Compute channel feature pyramid given an input image.</li><li><a href="gradientMag.html" class="code" title="function [M,O] = gradientMag( I, channel, normRad, normConst, full )">gradientMag</a>	Compute gradient magnitude and orientation at each image location.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = convTri( I, r, s, nomex )</a>
0002 <span class="comment">% Extremely fast 2D image convolution with a triangle filter.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Convolves an image by a 2D triangle filter (the 1D triangle filter f is</span>
0005 <span class="comment">% [1:r r+1 r:-1:1]/(r+1)^2, the 2D version is simply conv2(f,f')). The</span>
0006 <span class="comment">% convolution can be performed in constant time per-pixel, independent of</span>
0007 <span class="comment">% the radius r. In fact the implementation is nearly optimal, with the</span>
0008 <span class="comment">% convolution taking only slightly more time than creating a copy of the</span>
0009 <span class="comment">% input array. Boundary effects are handled as if the image were padded</span>
0010 <span class="comment">% symmetrically prior to performing the convolution. An optional integer</span>
0011 <span class="comment">% downsampling parameter &quot;s&quot; can be specified, in which case the output is</span>
0012 <span class="comment">% downsampled by s (the implementation is efficient with downsampling</span>
0013 <span class="comment">% occurring simultaneously with smoothing, saving additional time).</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% The output is exactly equivalent to the following Matlab operations:</span>
0016 <span class="comment">%  f = [1:r r+1 r:-1:1]/(r+1)^2;</span>
0017 <span class="comment">%  J = padarray(I,[r r],'symmetric','both');</span>
0018 <span class="comment">%  J = convn(convn(J,f,'valid'),f','valid');</span>
0019 <span class="comment">%  if(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); end</span>
0020 <span class="comment">% The computation, however, is an order of magnitude faster than the above.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% When used as a smoothing filter, the standard deviation (sigma) of a tri</span>
0023 <span class="comment">% filter with radius r can be computed using [sigma=sqrt(r*(r+2)/6)]. For</span>
0024 <span class="comment">% the first few values of r this translates to: r=1: sigma=1/sqrt(2), r=2:</span>
0025 <span class="comment">% sigma=sqrt(4/3), r=3: sqrt(5/2), r=4: sigma=2. Given sigma, the</span>
0026 <span class="comment">% equivalent value of r can be computed via [r=sqrt(6*sigma*sigma+1)-1].</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% For even finer grained control for very small amounts of smoothing, any</span>
0029 <span class="comment">% value of r between 0 and 1 can be used (normally if r&gt;=1 then r must be</span>
0030 <span class="comment">% an integer). In this case a filter of the form fp=[1 p 1]/(2+p) is used,</span>
0031 <span class="comment">% with p being determined automatically from r. The filter fp has a</span>
0032 <span class="comment">% standard deviation of [sigma=sqrt(2/(p+2))]. Hence p can be determined</span>
0033 <span class="comment">% from r by setting [sqrt(r*(r+2)/6)=sqrt(2/(p+2))], which gives</span>
0034 <span class="comment">% [p=12/r/(r+2)-2]. Note that r=1 gives p=2, so fp=[1 2 1]/4 which is the</span>
0035 <span class="comment">% same as the normal r=1 triangle filter. As r goes to 0, p goes to</span>
0036 <span class="comment">% infinity, and fp becomes the delta function [0 1 0]. The computation for</span>
0037 <span class="comment">% r&lt;=1 is particularly fast.</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% The related function convBox performs convolution with a box filter,</span>
0040 <span class="comment">% which is slightly faster but has worse properties if used for smoothing.</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% This code requires SSE2 to compile and run (most modern Intel and AMD</span>
0043 <span class="comment">% processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% USAGE</span>
0046 <span class="comment">%  J = convTri( I, r, [s], [nomex] )</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% INPUTS</span>
0049 <span class="comment">%  I      - [hxwxk] input k channel single image</span>
0050 <span class="comment">%  r      - integer filter radius (or any value between 0 and 1)</span>
0051 <span class="comment">%           filter standard deviation is: sigma=sqrt(r*(r+2)/6)</span>
0052 <span class="comment">%  s      - [1] integer downsampling amount after convolving</span>
0053 <span class="comment">%  nomex  - [0] if true perform computation in matlab (for testing/timing)</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% OUTPUTS</span>
0056 <span class="comment">%  J      - [hxwxk] smoothed image</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% EXAMPLE - matlab versus mex</span>
0059 <span class="comment">%  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;</span>
0060 <span class="comment">%  r = 5; s = 2; % set parameters as desired</span>
0061 <span class="comment">%  tic, J1=convTri(I,r,s); toc % mex version (fast)</span>
0062 <span class="comment">%  tic, J2=convTri(I,r,s,1); toc % matlab version (slow)</span>
0063 <span class="comment">%  figure(1); im(J1); figure(2); im(abs(J2-J1));</span>
0064 <span class="comment">%</span>
0065 <span class="comment">% EXAMPLE - triangle versus gaussian smoothing</span>
0066 <span class="comment">%  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;</span>
0067 <span class="comment">%  sigma = 4; rg = ceil(3*sigma); f = filterGauss(2*rg+1,[],sigma^2);</span>
0068 <span class="comment">%  tic, J1=conv2(conv2(imPad(I,rg,'symmetric'),f,'valid'),f','valid'); toc</span>
0069 <span class="comment">%  r=sqrt(6*sigma*sigma+1)-1; tic, J2=convTri(I,r); toc</span>
0070 <span class="comment">%  figure(1); im(J1); figure(2); im(J2); figure(3); im(abs(J2-J1));</span>
0071 <span class="comment">%</span>
0072 <span class="comment">% See also conv2, convBox, gaussSmooth</span>
0073 <span class="comment">%</span>
0074 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.02</span>
0075 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0076 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0077 
0078 <span class="keyword">if</span>( nargin&lt;3 ), s=1; <span class="keyword">end</span>
0079 <span class="keyword">if</span>( nargin&lt;4 ), nomex=0; <span class="keyword">end</span>
0080 <span class="keyword">if</span>( isempty(I) || (r==0 &amp;&amp; s==1) ), J = I; <span class="keyword">return</span>; <span class="keyword">end</span>
0081 m=min(size(I,1),size(I,2)); <span class="keyword">if</span>( m&lt;4 || 2*r+1&gt;=m ), nomex=1; <span class="keyword">end</span>
0082 
0083 <span class="keyword">if</span>( nomex==0 )
0084   <span class="keyword">if</span>( r&gt;0 &amp;&amp; r&lt;=1 &amp;&amp; s&lt;=2 )
0085     J = convConst(<span class="string">'convTri1'</span>,I,12/r/(r+2)-2,s);
0086   <span class="keyword">else</span>
0087     J = convConst(<span class="string">'convTri'</span>,I,r,s);
0088   <span class="keyword">end</span>
0089 <span class="keyword">else</span>
0090   <span class="keyword">if</span>(r&lt;=1), p=12/r/(r+2)-2; f=[1 p 1]/(2+p); r=1;
0091   <span class="keyword">else</span> f=[1:r r+1 r:-1:1]/(r+1)^2; <span class="keyword">end</span>
0092   J = padarray(I,[r r],<span class="string">'symmetric'</span>,<span class="string">'both'</span>);
0093   J = convn(convn(J,f,<span class="string">'valid'</span>),f',<span class="string">'valid'</span>);
0094   <span class="keyword">if</span>(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); <span class="keyword">end</span>
0095 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>