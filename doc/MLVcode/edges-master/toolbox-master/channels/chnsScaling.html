<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of chnsScaling</title>
  <meta name="keywords" content="chnsScaling">
  <meta name="description" content="Compute lambdas for channel power law scaling.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; chnsScaling.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>chnsScaling
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Compute lambdas for channel power law scaling.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [lambdas,as,scales,fs] = chnsScaling( pChns, Is, show ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute lambdas for channel power law scaling.

 For a broad family of features, including gradient histograms and all
 channel types tested, the feature responses computed at a single scale
 can be used to approximate feature responses at nearby scales. The
 approximation is accurate at least within an entire scale octave. For
 details and to understand why this unexpected result holds, please see:
   P. Dollár, R. Appel, S. Belongie and P. Perona
   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.

 This function computes channels at multiple image scales and plots the
 resulting power law scaling. The purpose of this function is two-fold:
 (1) compute lambdas for fast approximate channel computation for use in
 chnsPyramid() and (2) provide a visualization of the power law channel
 scaling described in the BMVC2010 paper.

 chnsScaling() takes two main inputs: the parameters for computing image
 channels (pChns), and an image or set of images (Is). The images are
 cropped to the dimension of the smallest image for simplicity of
 computing the lambdas (and fairly high resolution images are best). The
 computed lambdas will depend on the channel parameters (e.g. how much
 smoothing is performed), but given enough images (&gt;1000) the computed
 lambdas should not depend on the exact images used.

 USAGE
  [lambdas,as,scales,fs] = chnsScaling( pChns, Is, [show] )

 INPUTS
  pChns          - parameters for creating channels (see chnsCompute.m)
  Is             - [nImages x 1] cell array of images (nImages may be 1)
  show           - [1] figure in which to display results

 OUTPUTS
  lambdas        - [nTypes x 1] computed lambdas
  as             - [nTypes x 1] computed y-intercepts
  scales         - [nScales x 1] vector of actual scales used
  fs             - [nImages x nScales x nTypes] array of feature means

 EXAMPLE
  sDir = 'data/Inria/train/neg/';
  Is = fevalImages( @(x) {x}, {}, sDir, 'I', 'png', 0, 200 );
  p = chnsCompute(); lambdas = chnsScaling( p, Is, 1 );

 See also <a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>, <a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>, fevalImages

 Piotr's Computer Vision Matlab Toolbox      Version 3.25
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>	Compute channel feature pyramid given an input image.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [lambdas,as,scales,fs] = chnsScaling( pChns, Is, show )</a>
0002 <span class="comment">% Compute lambdas for channel power law scaling.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% For a broad family of features, including gradient histograms and all</span>
0005 <span class="comment">% channel types tested, the feature responses computed at a single scale</span>
0006 <span class="comment">% can be used to approximate feature responses at nearby scales. The</span>
0007 <span class="comment">% approximation is accurate at least within an entire scale octave. For</span>
0008 <span class="comment">% details and to understand why this unexpected result holds, please see:</span>
0009 <span class="comment">%   P. Dollár, R. Appel, S. Belongie and P. Perona</span>
0010 <span class="comment">%   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% This function computes channels at multiple image scales and plots the</span>
0013 <span class="comment">% resulting power law scaling. The purpose of this function is two-fold:</span>
0014 <span class="comment">% (1) compute lambdas for fast approximate channel computation for use in</span>
0015 <span class="comment">% chnsPyramid() and (2) provide a visualization of the power law channel</span>
0016 <span class="comment">% scaling described in the BMVC2010 paper.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% chnsScaling() takes two main inputs: the parameters for computing image</span>
0019 <span class="comment">% channels (pChns), and an image or set of images (Is). The images are</span>
0020 <span class="comment">% cropped to the dimension of the smallest image for simplicity of</span>
0021 <span class="comment">% computing the lambdas (and fairly high resolution images are best). The</span>
0022 <span class="comment">% computed lambdas will depend on the channel parameters (e.g. how much</span>
0023 <span class="comment">% smoothing is performed), but given enough images (&gt;1000) the computed</span>
0024 <span class="comment">% lambdas should not depend on the exact images used.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% USAGE</span>
0027 <span class="comment">%  [lambdas,as,scales,fs] = chnsScaling( pChns, Is, [show] )</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% INPUTS</span>
0030 <span class="comment">%  pChns          - parameters for creating channels (see chnsCompute.m)</span>
0031 <span class="comment">%  Is             - [nImages x 1] cell array of images (nImages may be 1)</span>
0032 <span class="comment">%  show           - [1] figure in which to display results</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% OUTPUTS</span>
0035 <span class="comment">%  lambdas        - [nTypes x 1] computed lambdas</span>
0036 <span class="comment">%  as             - [nTypes x 1] computed y-intercepts</span>
0037 <span class="comment">%  scales         - [nScales x 1] vector of actual scales used</span>
0038 <span class="comment">%  fs             - [nImages x nScales x nTypes] array of feature means</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% EXAMPLE</span>
0041 <span class="comment">%  sDir = 'data/Inria/train/neg/';</span>
0042 <span class="comment">%  Is = fevalImages( @(x) {x}, {}, sDir, 'I', 'png', 0, 200 );</span>
0043 <span class="comment">%  p = chnsCompute(); lambdas = chnsScaling( p, Is, 1 );</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% See also chnsCompute, chnsPyramid, fevalImages</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.25</span>
0048 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0049 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0050 
0051 <span class="comment">% get additional input arguments</span>
0052 <span class="keyword">if</span>(nargin&lt;3 || isempty(show)), show=1; <span class="keyword">end</span>
0053 
0054 <span class="comment">% construct pPyramid (don't pad, concat or appoximate)</span>
0055 pPyramid=<a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>(); pPyramid.pChns=pChns; pPyramid.concat=0;
0056 pPyramid.pad=[0 0]; pPyramid.nApprox=0; pPyramid.smooth=0;
0057 pPyramid.minDs(:)=max(8,pChns.shrink*4);
0058 
0059 <span class="comment">% crop all images to smallest image size</span>
0060 ds=[inf inf]; nImages=numel(Is);
0061 <span class="keyword">for</span> i=1:nImages, ds=min(ds,[size(Is{i},1) size(Is{i},2)]); <span class="keyword">end</span>
0062 ds=round(ds/pChns.shrink)*pChns.shrink;
0063 <span class="keyword">for</span> i=1:nImages, Is{i}=Is{i}(1:ds(1),1:ds(2),:); <span class="keyword">end</span>
0064 
0065 <span class="comment">% compute fs [nImages x nScales x nTypes] array of feature means</span>
0066 P=<a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>(Is{1},pPyramid); scales=P.scales'; info=P.info;
0067 nScales=P.nScales; nTypes=P.nTypes; fs=zeros(nImages,nScales,nTypes);
0068 parfor i=1:nImages, P=<a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>(Is{i},pPyramid); <span class="keyword">for</span> j=1:nScales
0069     <span class="keyword">for</span> k=1:nTypes, fs(i,j,k)=mean(P.data{j,k}(:)); <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">end</span>
0070 
0071 <span class="comment">% remove fs with fs(:,1,:) having small values</span>
0072 kp=max(fs(:,1,:)); kp=fs(:,1,:)&gt;kp(ones(1,nImages),1,:)/50;
0073 kp=min(kp,[],3); fs=fs(kp,:,:); nImages=size(fs,1);
0074 
0075 <span class="comment">% compute ratios, intercepts and lambdas using least squares</span>
0076 scales1=scales(2:end); nScales=nScales-1; O=ones(nScales,1);
0077 rs=fs(:,2:<span class="keyword">end</span>,:)./fs(:,O,:); mus=permute(mean(rs,1),[2 3 1]);
0078 out=[O -log2(scales1)]\log2(mus); as=2.^out(1,:); lambdas=out(2,:);
0079 <span class="keyword">if</span>(0), lambdas=-log2(scales1)\log2(mus); as(:)=1; <span class="keyword">end</span>
0080 <span class="keyword">if</span>(show==0), <span class="keyword">return</span>; <span class="keyword">end</span>
0081 
0082 <span class="comment">% compute predicted means and errors for display purposes</span>
0083 musp=as(O,:).*scales1(:,ones(1,nTypes)).^-lambdas(O,:);
0084 errsFit=mean(abs(musp-mus)); stds=permute(std(rs,0,1),[2 3 1]);
0085 
0086 <span class="comment">% plot results</span>
0087 <span class="keyword">if</span>(show&lt;0), show=-show; clear=0; <span class="keyword">else</span> clear=1; <span class="keyword">end</span>
0088 figureResized(.75,show); <span class="keyword">if</span>(clear), clf; <span class="keyword">end</span>
0089 lp={<span class="string">'LineWidth'</span>,2}; tp={<span class="string">'FontSize'</span>,12};
0090 <span class="keyword">for</span> k=1:nTypes
0091   <span class="comment">% plot ratios</span>
0092   subplot(2,nTypes,k); set(gca,tp{:});
0093   <span class="keyword">for</span> i=round(linspace(1,nImages,20))
0094     loglog(1./scales1,rs(i,:,k),<span class="string">'Color'</span>,[1 1 1]*.8); hold on; <span class="keyword">end</span>
0095   h0=loglog(1./scales1,mus(:,k),<span class="string">'go'</span>,lp{:});
0096   h1=loglog(1./scales1,musp(:,k),<span class="string">'b-'</span>,lp{:});
0097   title(sprintf(<span class="string">'%s\n\\lambda = %.03f,  error = %.2e'</span>,<span class="keyword">...</span>
0098     info(k).name,lambdas(k),errsFit(k)));
0099   legend([h0 h1],{<span class="string">'real'</span>,<span class="string">'fit'</span>},<span class="string">'location'</span>,<span class="string">'ne'</span>);
0100   xlabel(<span class="string">'log2(scale)'</span>); ylabel(<span class="string">'\mu (ratio)'</span>); axis tight;
0101   ax=axis; ax(1)=1; ax(3)=min(.9,ax(3)); ax(4)=max(2,ax(4)); axis(ax);
0102   set(gca,<span class="string">'ytick'</span>,[.5 1 1.4 2 3 4],<span class="string">'YMinorTick'</span>,<span class="string">'off'</span>);
0103   set(gca,<span class="string">'xtick'</span>,2.^(-10:.5:10),<span class="string">'XTickLabel'</span>,10:-.5:-10);
0104   <span class="comment">% plot variances</span>
0105   subplot(2,nTypes,k+nTypes); set(gca,tp{:});
0106   semilogx(1./scales1,stds(:,k),<span class="string">'go'</span>,lp{:}); hold on;
0107   xlabel(<span class="string">'log2(scale)'</span>); ylabel(<span class="string">'\sigma (ratio)'</span>); axis tight;
0108   ax=axis; ax(1)=1; ax(3)=0; ax(4)=max(.5,ax(4)); axis(ax);
0109   set(gca,<span class="string">'xtick'</span>,2.^(-10:.5:10),<span class="string">'XTickLabel'</span>,10:-.5:-10);
0110 <span class="keyword">end</span>
0111 
0112 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>