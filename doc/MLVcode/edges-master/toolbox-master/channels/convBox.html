<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of convBox</title>
  <meta name="keywords" content="convBox">
  <meta name="description" content="Extremely fast 2D image convolution with a box filter.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; convBox.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>convBox
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Extremely fast 2D image convolution with a box filter.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function J = convBox( I, r, s, nomex ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Extremely fast 2D image convolution with a box filter.

 Convolves an image by a F=ones(2*r+1,2*r+1)/(2*r+1)^2 filter. The
 convolution can be performed in constant time per-pixel, independent of
 the radius r. In fact the implementation is nearly optimal, with the
 convolution taking only slightly more time than creating a copy of the
 input array. Boundary effects are handled as if the image were padded
 symmetrically prior to performing the convolution. An optional integer
 downsampling parameter &quot;s&quot; can be specified, in which case the output is
 downsampled by s (the implementation is efficient with downsampling
 occurring simultaneously with smoothing, saving additional time).

 The output is exactly equivalent to the following Matlab operations:
  f = ones(1,2*r+1); f=f/sum(f);
  J = padarray(I,[r r],'symmetric','both');
  J = convn(convn(J,f,'valid'),f','valid');
  if(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); end
 The computation, however, is an order of magnitude faster than the above.

 When used as a smoothing filter, the standard deviation (sigma) of a box
 filter with radius r can be computed using [sigma=sqrt(r*(r+1)/3)]. For
 the first few values of r this translates to: r=1: sigma=sqrt(2/3), r=2:
 sigma=sqrt(2), r=3: sigma=2. Given sigma, the equivalent value of r can
 be computed via [r=sqrt(12*sigma*sigma+1)/2-.5].

 The related function convTri performs convolution with a triangle filter,
 which has nicer properties if used for smoothing, but is slightly slower.

 This code requires SSE2 to compile and run (most modern Intel and AMD
 processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.

 USAGE
  J = convBox( I, r, [s], [nomex] )

 INPUTS
  I      - [hxwxk] input k channel single image
  r      - integer filter radius
  s      - [1] integer downsampling amount after convolving
  nomex  - [0] if true perform computation in matlab (for testing/timing)

 OUTPUTS
  J      - [hxwxk] smoothed image

 EXAMPLE
  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;
  r = 5; s = 2; % set parameters as desired
  tic, J1=convBox(I,r,s); toc % mex version (fast)
  tic, J2=convBox(I,r,s,1); toc % matlab version (slow)
  figure(1); im(J1); figure(2); im(abs(J2-J1));

 See also conv2, <a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>

 Piotr's Computer Vision Matlab Toolbox      Version 3.02
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = convBox( I, r, s, nomex )</a>
0002 <span class="comment">% Extremely fast 2D image convolution with a box filter.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Convolves an image by a F=ones(2*r+1,2*r+1)/(2*r+1)^2 filter. The</span>
0005 <span class="comment">% convolution can be performed in constant time per-pixel, independent of</span>
0006 <span class="comment">% the radius r. In fact the implementation is nearly optimal, with the</span>
0007 <span class="comment">% convolution taking only slightly more time than creating a copy of the</span>
0008 <span class="comment">% input array. Boundary effects are handled as if the image were padded</span>
0009 <span class="comment">% symmetrically prior to performing the convolution. An optional integer</span>
0010 <span class="comment">% downsampling parameter &quot;s&quot; can be specified, in which case the output is</span>
0011 <span class="comment">% downsampled by s (the implementation is efficient with downsampling</span>
0012 <span class="comment">% occurring simultaneously with smoothing, saving additional time).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% The output is exactly equivalent to the following Matlab operations:</span>
0015 <span class="comment">%  f = ones(1,2*r+1); f=f/sum(f);</span>
0016 <span class="comment">%  J = padarray(I,[r r],'symmetric','both');</span>
0017 <span class="comment">%  J = convn(convn(J,f,'valid'),f','valid');</span>
0018 <span class="comment">%  if(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); end</span>
0019 <span class="comment">% The computation, however, is an order of magnitude faster than the above.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% When used as a smoothing filter, the standard deviation (sigma) of a box</span>
0022 <span class="comment">% filter with radius r can be computed using [sigma=sqrt(r*(r+1)/3)]. For</span>
0023 <span class="comment">% the first few values of r this translates to: r=1: sigma=sqrt(2/3), r=2:</span>
0024 <span class="comment">% sigma=sqrt(2), r=3: sigma=2. Given sigma, the equivalent value of r can</span>
0025 <span class="comment">% be computed via [r=sqrt(12*sigma*sigma+1)/2-.5].</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% The related function convTri performs convolution with a triangle filter,</span>
0028 <span class="comment">% which has nicer properties if used for smoothing, but is slightly slower.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% This code requires SSE2 to compile and run (most modern Intel and AMD</span>
0031 <span class="comment">% processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% USAGE</span>
0034 <span class="comment">%  J = convBox( I, r, [s], [nomex] )</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% INPUTS</span>
0037 <span class="comment">%  I      - [hxwxk] input k channel single image</span>
0038 <span class="comment">%  r      - integer filter radius</span>
0039 <span class="comment">%  s      - [1] integer downsampling amount after convolving</span>
0040 <span class="comment">%  nomex  - [0] if true perform computation in matlab (for testing/timing)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% OUTPUTS</span>
0043 <span class="comment">%  J      - [hxwxk] smoothed image</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% EXAMPLE</span>
0046 <span class="comment">%  I = single(imResample(imread('cameraman.tif'),[480 640]))/255;</span>
0047 <span class="comment">%  r = 5; s = 2; % set parameters as desired</span>
0048 <span class="comment">%  tic, J1=convBox(I,r,s); toc % mex version (fast)</span>
0049 <span class="comment">%  tic, J2=convBox(I,r,s,1); toc % matlab version (slow)</span>
0050 <span class="comment">%  figure(1); im(J1); figure(2); im(abs(J2-J1));</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% See also conv2, convTri</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.02</span>
0055 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0056 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0057 
0058 assert( r&gt;=0 );
0059 <span class="keyword">if</span>( nargin&lt;3 ), s=1; <span class="keyword">end</span>
0060 <span class="keyword">if</span>( nargin&lt;4 ), nomex=0; <span class="keyword">end</span>
0061 <span class="keyword">if</span>( isempty(I) || (r==0 &amp;&amp; s==1) ), J = I; <span class="keyword">return</span>; <span class="keyword">end</span>
0062 m=min(size(I,1),size(I,2)); <span class="keyword">if</span>( m&lt;4 || 2*r+1&gt;=m ), nomex=1; <span class="keyword">end</span>
0063 
0064 <span class="keyword">if</span>( nomex==0 )
0065   <span class="keyword">if</span>( r==1 &amp;&amp; s&lt;=2 )
0066     J = convConst(<span class="string">'convTri1'</span>,I,1,s);
0067   <span class="keyword">else</span>
0068     J = convConst(<span class="string">'convBox'</span>,I,r,s);
0069   <span class="keyword">end</span>
0070 <span class="keyword">else</span>
0071   f = ones(1,2*r+1); f=f/sum(f);
0072   J = padarray(I,[r r],<span class="string">'symmetric'</span>,<span class="string">'both'</span>);
0073   J = convn(convn(J,f,<span class="string">'valid'</span>),f',<span class="string">'valid'</span>);
0074   <span class="keyword">if</span>(s&gt;1), t=floor(s/2)+1; J=J(t:s:end-s+t,t:s:end-s+t,:); <span class="keyword">end</span>
0075 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>