<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rgbConvert</title>
  <meta name="keywords" content="rgbConvert">
  <meta name="description" content="Convert RGB image to other color spaces (highly optimized).">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; rgbConvert.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>rgbConvert
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Convert RGB image to other color spaces (highly optimized).</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function J = rgbConvert( I, colorSpace, useSingle ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Convert RGB image to other color spaces (highly optimized).

 If colorSpace=='gray' transforms I to grayscale. The output is within
 numerical error of Matlab's rgb2gray, except ~10x faster. The output in
 this case is hxwx1, and while the input must be hxwx3 for all other
 cases, the input for this case can also be hxwx1 (normalization only).

 If colorSpace=='hsv' transforms I to the HSV color space. The output is
 within numerical error of Matlab's rgb2hsv, except ~15x faster.

 If colorSpace=='rgb' or colorSpace='orig' only normalizes I to be in the
 range [0,1]. In this case both the input and output may have an arbitrary
 number of channels (that is I may be [hxwxd] for any d).

 If colorSpace=='luv' transforms I to the LUV color space. The LUV color
 space is &quot;perceptually uniform&quot; (meaning that two colors equally distant
 in the color space according to the Euclidean metric are equally distant
 perceptually). The L,u,v channels correspond roughly to luminance,
 green-red, blue-yellow. For more information see:
   http://en.wikipedia.org/wiki/CIELUV - using this color spaces
   http://en.wikipedia.org/wiki/CIELAB - more info about color spaces
 The LUV channels are normalized to fall in ~[0,1]. Without normalization
 the ranges are L~[0,100], u~[-88,182], and v~[-134,105] (and typically
 u,v~[-100,100]). The applied transformation is L=L/270, u=(u+88)/270, and
 v=(v+134)/270. This results in ranges L~[0,.37], u~[0,1], and v~[0,.89].
 Perceptual uniformity is maintained since divisor is constant
 (normalizing each color channel independently would break uniformity).
 To undo the normalization on an LUV image J use:
   J=J*270; J(:,:,2)=J(:,:,2)-88; J(:,:,3)=J(:,:,3)-134;
 To test the range of the colorSpace use:
   R=100; I=zeros(R^3,1,3); k=1; R=linspace(0,1,R);
   for r=R, for g=R, for b=R, I(k,1,:)=[r g b]; k=k+1; end; end; end
   J=rgbConvert(I,'luv'); [min(J), max(J)]

 This code requires SSE2 to compile and run (most modern Intel and AMD
 processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.

 USAGE
  J = rgbConvert( I, colorSpace, [useSingle] );

 INPUTS
  I          - [hxwx3] input rgb image (uint8 or single/double in [0,1])
  colorSpace - ['luv'] other choices include: 'gray', 'hsv', 'rgb', 'orig'
  useSingle  - [true] determines output type (faster if useSingle)

 OUTPUTS
  J          - [hxwx3] single or double output image (normalized to [0,1])

 EXAMPLE - luv
  I = imread('peppers.png');
  tic, J = rgbConvert( I, 'luv' ); toc
  figure(1); montage2( J );

 EXAMPLE - hsv
  I=imread('peppers.png');
  tic, J1=rgb2hsv( I ); toc
  tic, J2=rgbConvert( I, 'hsv' ); toc
  mean2(abs(J1-J2))

 EXAMPLE - gray
  I=imread('peppers.png');
  tic, J1=rgb2gray( I ); toc
  tic, J2=rgbConvert( I, 'gray' ); toc
  J1=single(J1)/255; mean2(abs(J1-J2))

 See also rgb2hsv, rgb2gray

 Piotr's Computer Vision Matlab Toolbox      Version 3.02
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>	Compute channel features at a single scale given an input image.</li><li><a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>	Compute channel feature pyramid given an input image.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = rgbConvert( I, colorSpace, useSingle )</a>
0002 <span class="comment">% Convert RGB image to other color spaces (highly optimized).</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% If colorSpace=='gray' transforms I to grayscale. The output is within</span>
0005 <span class="comment">% numerical error of Matlab's rgb2gray, except ~10x faster. The output in</span>
0006 <span class="comment">% this case is hxwx1, and while the input must be hxwx3 for all other</span>
0007 <span class="comment">% cases, the input for this case can also be hxwx1 (normalization only).</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% If colorSpace=='hsv' transforms I to the HSV color space. The output is</span>
0010 <span class="comment">% within numerical error of Matlab's rgb2hsv, except ~15x faster.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% If colorSpace=='rgb' or colorSpace='orig' only normalizes I to be in the</span>
0013 <span class="comment">% range [0,1]. In this case both the input and output may have an arbitrary</span>
0014 <span class="comment">% number of channels (that is I may be [hxwxd] for any d).</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% If colorSpace=='luv' transforms I to the LUV color space. The LUV color</span>
0017 <span class="comment">% space is &quot;perceptually uniform&quot; (meaning that two colors equally distant</span>
0018 <span class="comment">% in the color space according to the Euclidean metric are equally distant</span>
0019 <span class="comment">% perceptually). The L,u,v channels correspond roughly to luminance,</span>
0020 <span class="comment">% green-red, blue-yellow. For more information see:</span>
0021 <span class="comment">%   http://en.wikipedia.org/wiki/CIELUV - using this color spaces</span>
0022 <span class="comment">%   http://en.wikipedia.org/wiki/CIELAB - more info about color spaces</span>
0023 <span class="comment">% The LUV channels are normalized to fall in ~[0,1]. Without normalization</span>
0024 <span class="comment">% the ranges are L~[0,100], u~[-88,182], and v~[-134,105] (and typically</span>
0025 <span class="comment">% u,v~[-100,100]). The applied transformation is L=L/270, u=(u+88)/270, and</span>
0026 <span class="comment">% v=(v+134)/270. This results in ranges L~[0,.37], u~[0,1], and v~[0,.89].</span>
0027 <span class="comment">% Perceptual uniformity is maintained since divisor is constant</span>
0028 <span class="comment">% (normalizing each color channel independently would break uniformity).</span>
0029 <span class="comment">% To undo the normalization on an LUV image J use:</span>
0030 <span class="comment">%   J=J*270; J(:,:,2)=J(:,:,2)-88; J(:,:,3)=J(:,:,3)-134;</span>
0031 <span class="comment">% To test the range of the colorSpace use:</span>
0032 <span class="comment">%   R=100; I=zeros(R^3,1,3); k=1; R=linspace(0,1,R);</span>
0033 <span class="comment">%   for r=R, for g=R, for b=R, I(k,1,:)=[r g b]; k=k+1; end; end; end</span>
0034 <span class="comment">%   J=rgbConvert(I,'luv'); [min(J), max(J)]</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% This code requires SSE2 to compile and run (most modern Intel and AMD</span>
0037 <span class="comment">% processors support SSE2). Please see: http://en.wikipedia.org/wiki/SSE2.</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% USAGE</span>
0040 <span class="comment">%  J = rgbConvert( I, colorSpace, [useSingle] );</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% INPUTS</span>
0043 <span class="comment">%  I          - [hxwx3] input rgb image (uint8 or single/double in [0,1])</span>
0044 <span class="comment">%  colorSpace - ['luv'] other choices include: 'gray', 'hsv', 'rgb', 'orig'</span>
0045 <span class="comment">%  useSingle  - [true] determines output type (faster if useSingle)</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% OUTPUTS</span>
0048 <span class="comment">%  J          - [hxwx3] single or double output image (normalized to [0,1])</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% EXAMPLE - luv</span>
0051 <span class="comment">%  I = imread('peppers.png');</span>
0052 <span class="comment">%  tic, J = rgbConvert( I, 'luv' ); toc</span>
0053 <span class="comment">%  figure(1); montage2( J );</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% EXAMPLE - hsv</span>
0056 <span class="comment">%  I=imread('peppers.png');</span>
0057 <span class="comment">%  tic, J1=rgb2hsv( I ); toc</span>
0058 <span class="comment">%  tic, J2=rgbConvert( I, 'hsv' ); toc</span>
0059 <span class="comment">%  mean2(abs(J1-J2))</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% EXAMPLE - gray</span>
0062 <span class="comment">%  I=imread('peppers.png');</span>
0063 <span class="comment">%  tic, J1=rgb2gray( I ); toc</span>
0064 <span class="comment">%  tic, J2=rgbConvert( I, 'gray' ); toc</span>
0065 <span class="comment">%  J1=single(J1)/255; mean2(abs(J1-J2))</span>
0066 <span class="comment">%</span>
0067 <span class="comment">% See also rgb2hsv, rgb2gray</span>
0068 <span class="comment">%</span>
0069 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.02</span>
0070 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0071 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0072 
0073 <span class="keyword">if</span>(nargin&lt;3 || isempty(useSingle)), useSingle=true; <span class="keyword">end</span>
0074 flag = find(strcmpi(colorSpace,{<span class="string">'gray'</span>,<span class="string">'rgb'</span>,<span class="string">'luv'</span>,<span class="string">'hsv'</span>,<span class="string">'orig'</span>}))-1;
0075 <span class="keyword">if</span>(isempty(flag)), error(<span class="string">'unknown colorSpace: %s'</span>,colorSpace); <span class="keyword">end</span>
0076 <span class="keyword">if</span>(useSingle), outClass=<span class="string">'single'</span>; <span class="keyword">else</span> outClass=<span class="string">'double'</span>; <span class="keyword">end</span>
0077 <span class="keyword">if</span>(isempty(I) &amp;&amp; flag&gt;0 &amp;&amp; flag~=4), I=I(:,:,[1 1 1]); <span class="keyword">end</span>
0078 d=size(I,3); <span class="keyword">if</span>(flag==4), flag=1; <span class="keyword">end</span>; norm=(d==1 &amp;&amp; flag==0) || flag==1;
0079 <span class="keyword">if</span>( norm &amp;&amp; isa(I,outClass) ), J=I; <span class="keyword">return</span>; <span class="keyword">end</span>
0080 J=rgbConvertMex(I,flag,useSingle);</pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>