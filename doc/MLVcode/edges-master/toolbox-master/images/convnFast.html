<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of convnFast</title>
  <meta name="keywords" content="convnFast">
  <meta name="description" content="Fast convolution, replacement for both conv2 and convn.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">images</a> &gt; convnFast.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\images&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>convnFast
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Fast convolution, replacement for both conv2 and convn.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function C = convnFast( A, B, shape ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Fast convolution, replacement for both conv2 and convn.

 See conv2 or convn for more information on convolution in general.

 This works as a replacement for both conv2 and convn.  Basically,
 performs convolution in either the frequency or spatial domain, depending
 on which it thinks will be faster (see below). In general, if A is much
 bigger then B then spatial convolution will be faster, but if B is of
 similar size to A and both are fairly big (such as in the case of
 correlation), convolution as multiplication in the frequency domain will
 tend to be faster.

 The shape flag can take on 1 additional value which is 'smooth'.  This
 flag is intended for use with smoothing kernels.  The returned matrix C
 is the same size as A with boundary effects handled in a special manner.
 That is instead of A being zero padded before being convolved with B;
 near the boundaries a cropped version of the matrix B is used, and the
 results is scaled by the fraction of the weight found in  the cropped
 version of B.  In this case each dimension of B must be odd, and all
 elements of B must be positive.  There are other restrictions on when
 this flag can be used, and in general it is only useful for smoothing
 kernels.  For 2D filtering it does not have much overhead, for 3D it has
 more and for higher dimensions much much more.

 For optimal performance some timing constants must be set to choose
 between doing convolution in the spatial and frequency domains, for more
 info see timeConv below.

 USAGE
  C = convnFast( A, B, [shape] )

 INPUTS
  A       - d dimensional input matrix
  B       - d dimensional matrix to convolve with A
  shape   - ['full'] 'valid', 'full', 'same', or 'smooth'

 OUTPUTS
  C       - result of convolution

 EXAMPLE

 See also CONV2, CONVN

 Piotr's Computer Vision Matlab Toolbox      Version 2.61
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="convnFast.html" class="code" title="function C = convnFast( A, B, shape )">convnFast</a>	Fast convolution, replacement for both conv2 and convn.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="convnFast.html" class="code" title="function C = convnFast( A, B, shape )">convnFast</a>	Fast convolution, replacement for both conv2 and convn.</li><li><a href="gaussSmooth.html" class="code" title="function [L,filters] = gaussSmooth( I, sigmas, shape, radius )">gaussSmooth</a>	Applies Gaussian smoothing to a (multidimensional) image.</li><li><a href="histcImWin.html" class="code" title="function H = histcImWin( I, edges, wtMask, shape )">histcImWin</a>	Calculates local histograms at every point in an image I.</li><li><a href="normxcorrn.html" class="code" title="function C = normxcorrn( T, A, shape, Tm )">normxcorrn</a>	Normalized n-dimensional cross-correlation.</li><li><a href="xcorrn.html" class="code" title="function C = xcorrn( A, T, shape )">xcorrn</a>	n-dimensional cross-correlation.  Generalized version of xcorr2.</li><li><a href="xeucn.html" class="code" title="function C = xeucn( A, T, shape )">xeucn</a>	n-dimensional euclidean distance between each window in A and template T.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function C = convnBound( A, B, C, sizA, sizB )</a></li><li><a href="#_sub2" class="code">function C = convnFreq( A, B, sizA, sizB, shape )</a></li><li><a href="#_sub3" class="code">function K = timeConv()</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function C = convnFast( A, B, shape )</a>
0002 <span class="comment">% Fast convolution, replacement for both conv2 and convn.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% See conv2 or convn for more information on convolution in general.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This works as a replacement for both conv2 and convn.  Basically,</span>
0007 <span class="comment">% performs convolution in either the frequency or spatial domain, depending</span>
0008 <span class="comment">% on which it thinks will be faster (see below). In general, if A is much</span>
0009 <span class="comment">% bigger then B then spatial convolution will be faster, but if B is of</span>
0010 <span class="comment">% similar size to A and both are fairly big (such as in the case of</span>
0011 <span class="comment">% correlation), convolution as multiplication in the frequency domain will</span>
0012 <span class="comment">% tend to be faster.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% The shape flag can take on 1 additional value which is 'smooth'.  This</span>
0015 <span class="comment">% flag is intended for use with smoothing kernels.  The returned matrix C</span>
0016 <span class="comment">% is the same size as A with boundary effects handled in a special manner.</span>
0017 <span class="comment">% That is instead of A being zero padded before being convolved with B;</span>
0018 <span class="comment">% near the boundaries a cropped version of the matrix B is used, and the</span>
0019 <span class="comment">% results is scaled by the fraction of the weight found in  the cropped</span>
0020 <span class="comment">% version of B.  In this case each dimension of B must be odd, and all</span>
0021 <span class="comment">% elements of B must be positive.  There are other restrictions on when</span>
0022 <span class="comment">% this flag can be used, and in general it is only useful for smoothing</span>
0023 <span class="comment">% kernels.  For 2D filtering it does not have much overhead, for 3D it has</span>
0024 <span class="comment">% more and for higher dimensions much much more.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% For optimal performance some timing constants must be set to choose</span>
0027 <span class="comment">% between doing convolution in the spatial and frequency domains, for more</span>
0028 <span class="comment">% info see timeConv below.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% USAGE</span>
0031 <span class="comment">%  C = convnFast( A, B, [shape] )</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% INPUTS</span>
0034 <span class="comment">%  A       - d dimensional input matrix</span>
0035 <span class="comment">%  B       - d dimensional matrix to convolve with A</span>
0036 <span class="comment">%  shape   - ['full'] 'valid', 'full', 'same', or 'smooth'</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% OUTPUTS</span>
0039 <span class="comment">%  C       - result of convolution</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% EXAMPLE</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also CONV2, CONVN</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 2.61</span>
0046 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0047 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0048 
0049 <span class="keyword">if</span>( nargin&lt;3 || isempty(shape)); shape=<span class="string">'full'</span>; <span class="keyword">end</span>
0050 <span class="keyword">if</span>( ~any(strcmp(shape,{<span class="string">'same'</span>, <span class="string">'valid'</span>, <span class="string">'full'</span>, <span class="string">'smooth'</span>})) )
0051   error( <span class="string">'convnFast: unknown shape flag'</span> ); <span class="keyword">end</span>
0052 
0053 shapeorig = shape;
0054 smoothFlag = (strcmp(shape,<span class="string">'smooth'</span>));
0055 <span class="keyword">if</span>( smoothFlag ); shape = <span class="string">'same'</span>; <span class="keyword">end</span>;
0056 
0057 <span class="comment">% get dimensions of A and B</span>
0058 ndA = ndims(A);  ndB = ndims(B); nd = max(ndA,ndB);
0059 sizA = size(A); sizB = size(B);
0060 <span class="keyword">if</span> (ndA&gt;ndB); sizB = [sizB ones(1,ndA-ndB)]; <span class="keyword">end</span>
0061 <span class="keyword">if</span> (ndA&lt;ndB); sizA = [sizA ones(1,ndB-ndA)]; <span class="keyword">end</span>
0062 
0063 <span class="comment">% ERROR CHECK if smoothflag</span>
0064 <span class="keyword">if</span>( smoothFlag )
0065   <span class="keyword">if</span>( ~all( mod(sizB,2)==1 ) )
0066     error(<span class="string">'If flag==''smooth'' then must have odd sized mask'</span>);
0067   <span class="keyword">end</span>;
0068   <span class="keyword">if</span>( ~all( B&gt;0 ) )
0069     error(<span class="string">'If flag==''smooth'' then mask must have &gt;0 values.'</span>);
0070   <span class="keyword">end</span>;
0071   <span class="keyword">if</span>( any( (sizB-1)/2&gt;sizA ) )
0072     error(<span class="string">'B is more then twice as big as A, cannot use flag==''smooth'''</span>);
0073   <span class="keyword">end</span>;
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">% OPTIMIZATION for 3D conv when B is actually 2D - calls (spatial) conv2</span>
0077 <span class="comment">% repeatedly on 2D slices of A.  Note that may need to rearange A and B</span>
0078 <span class="comment">% first and use recursion. The benefits carry over to convnBound</span>
0079 <span class="comment">% (which is faster for 2D arrays).</span>
0080 <span class="keyword">if</span>( ndA==3 &amp;&amp; ndB==3 &amp;&amp; (sizB(1)==1 || sizB(2)==1) )
0081   <span class="keyword">if</span> (sizB(1)==1)
0082     A = permute( A, [2 3 1]);  B = permute( B, [2 3 1]);
0083     C = <a href="convnFast.html" class="code" title="function C = convnFast( A, B, shape )">convnFast</a>( A, B, shapeorig );
0084     C = permute( C, [3 1 2] );
0085   <span class="keyword">elseif</span> (sizB(2)==1)
0086     A = permute( A, [3 1 2]);  B = permute( B, [3 1 2]);
0087     C = <a href="convnFast.html" class="code" title="function C = convnFast( A, B, shape )">convnFast</a>( A, B, shapeorig );
0088     C = permute( C, [2 3 1] );
0089   <span class="keyword">end</span>
0090   <span class="keyword">return</span>;
0091 <span class="keyword">elseif</span>( ndA==3 &amp;&amp; ndB==2 )
0092   C1 = conv2( A(:,:,1), B, shape );
0093   C = zeros( [size(C1), sizA(3)] ); C(:,:,1) = C1;
0094   <span class="keyword">for</span> i=2:sizA(3); C(:,:,i) = conv2( A(:,:,i), B, shape ); <span class="keyword">end</span>
0095   <span class="keyword">if</span> (smoothFlag)
0096     <span class="keyword">for</span> i=1:sizA(3)
0097       C(:,:,i) = <a href="#_sub1" class="code" title="subfunction C = convnBound( A, B, C, sizA, sizB )">convnBound</a>(A(:,:,i),B,C(:,:,i),sizA(1:2),sizB(1:2));
0098     <span class="keyword">end</span>
0099   <span class="keyword">end</span>
0100   <span class="keyword">return</span>;
0101 <span class="keyword">end</span>
0102 
0103 <span class="comment">% get predicted time of convolution in frequency and spatial domain</span>
0104 <span class="comment">% constants taken from timeConv</span>
0105 sizfft = 2.^ceil(real(log2(sizA+sizB-1))); psizfft=prod(sizfft);
0106 frequenPt = 3 * 1e-7 * psizfft * log(psizfft);
0107 <span class="keyword">if</span> (nd==2)
0108   spatialPt = 5e-9 * sizA(1) * sizA(2) * sizB(1) * sizB(2);
0109 <span class="keyword">else</span>
0110   spatialPt = 5e-8 * prod(sizA) * prod(sizB);
0111 <span class="keyword">end</span>
0112 
0113 <span class="comment">% perform convolution</span>
0114 <span class="keyword">if</span> ( spatialPt &lt; frequenPt )
0115   <span class="keyword">if</span> (nd==2)
0116     C = conv2( A, B, shape );
0117   <span class="keyword">else</span>
0118     C = convn( A, B, shape );
0119   <span class="keyword">end</span>
0120 <span class="keyword">else</span>
0121   C = <a href="#_sub2" class="code" title="subfunction C = convnFreq( A, B, sizA, sizB, shape )">convnFreq</a>( A, B, sizA, sizB, shape );
0122 <span class="keyword">end</span>;
0123 
0124 
0125 <span class="comment">% now correct boundary effects (if shape=='smooth')</span>
0126 <span class="keyword">if</span>( ~smoothFlag ); <span class="keyword">return</span>; <span class="keyword">end</span>;
0127 C = <a href="#_sub1" class="code" title="subfunction C = convnBound( A, B, C, sizA, sizB )">convnBound</a>( A, B, C, sizA, sizB );
0128 
0129 <a name="_sub1" href="#_subfunctions" class="code">function C = convnBound( A, B, C, sizA, sizB )</a>
0130 <span class="comment">% calculate boundary values for C in spatial domain</span>
0131 
0132 nd = length(sizA);
0133 radii = (sizB-1)/2;
0134 
0135 <span class="comment">% flip B appropriately (conv flips B)</span>
0136 <span class="keyword">for</span> d=1:nd; B = flipdim(B,d); <span class="keyword">end</span>
0137 
0138 <span class="comment">% accelerated case for 1D mask B</span>
0139 <span class="keyword">if</span>( nd==2 &amp;&amp; sizB(1)==1 )
0140   sumB=sum(B(:)); r=radii(2); O=ones(1,sizA(1));
0141   <span class="keyword">for</span> i=1:r
0142     Ai=A(:,1:r+i); Bi=B(r+2-i:end);
0143     C(:,i)=sum(Ai.*Bi(O,:),2)/sum(Bi)*sumB;
0144     Ai=A(:,end+1-r-i:end); Bi=B(1:(end-r+i-1));
0145     C(:,end-i+1)=sum(Ai.*Bi(O,:),2)/sum(Bi)*sumB;
0146   <span class="keyword">end</span>; <span class="keyword">return</span>;
0147 <span class="keyword">elseif</span>( nd==2 &amp;&amp; sizB(2)==1 )
0148   sumB=sum(B(:)); r=radii(1); O=ones(1,sizA(2));
0149   <span class="keyword">for</span> i=1:r
0150     Ai=A(1:r+i,:); Bi=B(r+2-i:end);
0151     C(i,:)=sum(Ai.*Bi(:,O),1)/sum(Bi)*sumB;
0152     Ai=A(end+1-r-i:<span class="keyword">end</span>,:); Bi=B(1:(end-r+i-1));
0153     C(end-i+1,:)=sum(Ai.*Bi(:,O),1)/sum(Bi)*sumB;
0154   <span class="keyword">end</span>; <span class="keyword">return</span>;
0155 <span class="keyword">end</span>
0156 
0157 <span class="comment">% get location that need to be updated</span>
0158 inds = {<span class="string">':'</span>}; inds = inds(:,ones(1,nd));
0159 Dind = zeros( sizA );
0160 <span class="keyword">for</span> d=1:nd
0161   inds1 = inds; inds1{ d } = 1:radii(d);
0162   inds2 = inds; inds2{ d } = sizA(d)-radii(d)+1:sizA(d);
0163   Dind(inds1{:}) = 1;  Dind(inds2{:}) = 1;
0164 <span class="keyword">end</span>
0165 Dind = find( Dind );
0166 Dndx = ind2sub2( sizA, Dind );
0167 nlocs = length(Dind);
0168 
0169 <span class="comment">% get cuboid dimensions for all the boundary regions</span>
0170 sizeArep = repmat( sizA, [nlocs,1] );
0171 radiiRep = repmat( radii, [nlocs,1] );
0172 Astarts = max(1,Dndx-radiiRep);
0173 Aends = min( sizeArep, Dndx+radiiRep);
0174 Bstarts = Astarts + (1-Dndx+radiiRep);
0175 Bends = Bstarts + (Aends-Astarts);
0176 
0177 <span class="comment">% now update these locations</span>
0178 vs = zeros( 1, nlocs );
0179 <span class="keyword">if</span>( nd==2 )
0180   <span class="keyword">for</span> i=1:nlocs <span class="comment">% accelerated for 2D arrays</span>
0181     Apart = A( Astarts(i,1):Aends(i,1), Astarts(i,2):Aends(i,2) );
0182     Bpart = B( Bstarts(i,1):Bends(i,1), Bstarts(i,2):Bends(i,2) );
0183     v = (Apart.*Bpart); vs(i) = sum(v(:)) ./ sum(Bpart(:));
0184   <span class="keyword">end</span>
0185 <span class="keyword">elseif</span>( nd==3 ) <span class="comment">% accelerated for 3D arrays</span>
0186   <span class="keyword">for</span> i=1:nlocs
0187     Apart = A( Astarts(i,1):Aends(i,1), Astarts(i,2):Aends(i,2), <span class="keyword">...</span>
0188       Astarts(i,3):Aends(i,3) );
0189     Bpart = B( Bstarts(i,1):Bends(i,1), Bstarts(i,2):Bends(i,2), <span class="keyword">...</span>
0190       Bstarts(i,3):Bends(i,3) );
0191     za = sum(sum(sum(Apart.*Bpart))); zb=sum(sum(sum(Bpart)));
0192     vs(1,i) = za./zb;
0193   <span class="keyword">end</span>
0194 <span class="keyword">else</span> <span class="comment">% general case [slow]</span>
0195   extract=cell(1,nd);
0196   <span class="keyword">for</span> i=1:nlocs
0197     <span class="keyword">for</span> d=1:nd; extract{d} = Astarts(i,d):Aends(i,d); <span class="keyword">end</span>
0198     Apart = A( extract{:} );
0199     <span class="keyword">for</span> d=1:nd; extract{d} = Bstarts(i,d):Bends(i,d); <span class="keyword">end</span>
0200     Bpart = B( extract{:} );
0201     v = (Apart.*Bpart); vs(i) = sum(v(:)) ./ sum(Bpart(:));
0202   <span class="keyword">end</span>
0203 <span class="keyword">end</span>
0204 C( Dind ) = vs * sum(B(:));
0205 
0206 <a name="_sub2" href="#_subfunctions" class="code">function C = convnFreq( A, B, sizA, sizB, shape )</a>
0207 <span class="comment">% Convolution as multiplication in the frequency domain</span>
0208 
0209 siz = sizA + sizB - 1;
0210 
0211 <span class="comment">% calculate correlation in frequency domain</span>
0212 Fa = fftn(A,siz);
0213 Fb = fftn(B,siz);
0214 C = ifftn(Fa .* Fb);
0215 
0216 <span class="comment">% make sure output is real if inputs were both real</span>
0217 <span class="keyword">if</span>(isreal(A) &amp;&amp; isreal(B)); C = real(C); <span class="keyword">end</span>
0218 
0219 <span class="comment">% crop to size</span>
0220 <span class="keyword">if</span>(strcmp(shape,<span class="string">'valid'</span>))
0221   C = arrayToDims( C, max(0,sizA-sizB+1 ) );
0222 <span class="keyword">elseif</span>(strcmp(shape,<span class="string">'same'</span>))
0223   C = arrayToDims( C, sizA );
0224 <span class="keyword">elseif</span>(~strcmp(shape,<span class="string">'full'</span>))
0225   error(<span class="string">'unknown shape'</span>);
0226 <span class="keyword">end</span>
0227 
0228 <a name="_sub3" href="#_subfunctions" class="code">function K = timeConv() </a><span class="comment">%#ok&lt;DEFNU&gt;</span>
0229 <span class="comment">% Function used to calculate constants for prediction of convolution in the</span>
0230 <span class="comment">% frequency and spatial domains.  Method taken from normxcorr2.m</span>
0231 <span class="comment">% May need to reset K's if placing this on a new machine, however, their</span>
0232 <span class="comment">% ratio should be about the same..</span>
0233 
0234 mintime = 4;
0235 
0236 <span class="keyword">switch</span> 3
0237   <span class="keyword">case</span> 1  <span class="comment">% conv2  [[empirically K = 5e-9]]</span>
0238     <span class="comment">% convolution time = K*prod(size(a))*prod(size(b))</span>
0239     siza = 30;  sizb = 200;
0240     a = ones(siza);  b = ones(sizb);
0241     t1 = cputime;  t2 = t1; k = 0;
0242     <span class="keyword">while</span> (t2-t1)&lt;mintime;
0243       disc = conv2(a,b); k = k + 1; t2 = cputime; <span class="comment">%#ok&lt;NASGU&gt;</span>
0244     <span class="keyword">end</span>
0245     K = (t2-t1)/k/siza^2/sizb^2;
0246     
0247   <span class="keyword">case</span> 2  <span class="comment">% convn  [[empirically K = 5e-8]]</span>
0248     <span class="comment">% convolution time = K*prod(size(a))*prod(size(b))</span>
0249     siza = [10 10 10];  sizb = [30 30 10];
0250     a = ones(siza);  b = ones(sizb);
0251     t1 = cputime;  t2 = t1;  k = 0;
0252     <span class="keyword">while</span> (t2-t1)&lt;mintime;
0253       disc = convn(a,b); k = k + 1; t2 = cputime; <span class="comment">%#ok&lt;NASGU&gt;</span>
0254     <span class="keyword">end</span>
0255     K = (t2-t1)/k/prod(siza)/prod(sizb);
0256     
0257   <span class="keyword">case</span> 3 <span class="comment">% fft (one dimensional) [[empirically K = 1e-7]]</span>
0258     <span class="comment">% fft time = K * n log(n)  [if n is power of 2]</span>
0259     <span class="comment">% Works fastest for powers of 2.  (so always zero pad until have</span>
0260     <span class="comment">% size of power of 2?).  2 dimensional fft has to apply single</span>
0261     <span class="comment">% dimensional fft to each column, and then signle dimensional fft</span>
0262     <span class="comment">% to each resulting row.  time = K * (mn)log(mn).  Likewise for</span>
0263     <span class="comment">% highter dimensions.  convnFreq requires 3 such ffts.</span>
0264     n = 2^nextpow2(2^15);
0265     vec = complex(rand(n,1),rand(n,1));
0266     t1 = cputime;  t2 = t1;  k = 0;
0267     <span class="keyword">while</span> (t2-t1) &lt; mintime;
0268       disc = fft(vec); k = k + 1; t2 = cputime; <span class="comment">%#ok&lt;NASGU&gt;</span>
0269     <span class="keyword">end</span>
0270     K = (t2-t1) / k / n / log(n);
0271 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>