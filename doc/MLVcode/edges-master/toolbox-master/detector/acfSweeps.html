<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of acfSweeps</title>
  <meta name="keywords" content="acfSweeps">
  <meta name="description" content="Parameter sweeps for ACF pedestrian detector.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">detector</a> &gt; acfSweeps.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\detector&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>acfSweeps
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Parameter sweeps for ACF pedestrian detector.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function acfSweeps </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Parameter sweeps for ACF pedestrian detector.

 Running the parameter sweeps requires altering internal flags.
 The sweeps are not well documented, use at your own discretion.

 Piotr's Computer Vision Matlab Toolbox      Version 3.50
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="acfTest.html" class="code" title="function [miss,roc,gt,dt] = acfTest( varargin )">acfTest</a>	Test aggregate channel features object detector given ground truth.</li><li><a href="acfTrain.html" class="code" title="function detector = acfTrain( varargin )">acfTrain</a>	Train aggregate channel features object detector.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function plotExps( rtDir, expNm, opts, lgd, lbl, T )</a></li><li><a href="#_sub2" class="code">function [jobsTrn,jobsTst] = createJobs( rtDir, opts, T )</a></li><li><a href="#_sub3" class="code">function [opts,lgd,lbl] = createExp( rtDir, expNm )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function acfSweeps</a>
0002 <span class="comment">% Parameter sweeps for ACF pedestrian detector.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Running the parameter sweeps requires altering internal flags.</span>
0005 <span class="comment">% The sweeps are not well documented, use at your own discretion.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.50</span>
0008 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0009 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0010 
0011 <span class="comment">% specify type and location of cluster (see fevalDistr.m)</span>
0012 rtDir=[fileparts(fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)))) <span class="string">'/data/'</span>];
0013 pDistr={<span class="string">'type'</span>,<span class="string">'parfor'</span>}; <span class="keyword">if</span>(0), matlabpool(<span class="string">'open'</span>,11); <span class="keyword">end</span>
0014 
0015 <span class="comment">% define all parameter sweeps</span>
0016 expNms = {<span class="string">'FtrsColorSpace'</span>,<span class="string">'FtrsChnTypes'</span>,<span class="string">'FtrsGradColorChn'</span>,<span class="keyword">...</span>
0017   <span class="string">'FtrsGradNormRad'</span>,<span class="string">'FtrsGradNormConst'</span>,<span class="string">'FtrsGradOrients'</span>,<span class="keyword">...</span>
0018   <span class="string">'FtrsGradSoftBins'</span>,<span class="string">'FtrsSmoothIm'</span>,<span class="string">'FtrsSmoothChns'</span>,<span class="string">'FtrsShrink'</span>,<span class="keyword">...</span>
0019   <span class="string">'DetModelDs'</span>,<span class="string">'DetModelDsPad'</span>,<span class="string">'DetStride'</span>,<span class="string">'DetNumOctaves'</span>,<span class="keyword">...</span>
0020   <span class="string">'DetNumApprox'</span>,<span class="string">'DetLambda'</span>,<span class="string">'DetCascThr'</span>,<span class="string">'DetCascCal'</span>,<span class="string">'DetNmsThr'</span>,<span class="keyword">...</span>
0021   <span class="string">'TrnNumWeak'</span>,<span class="string">'TrnNumBoot'</span>,<span class="string">'TrnDepth'</span>,<span class="string">'TrnNumBins'</span>,<span class="string">'TrnFracFtrs'</span>,<span class="keyword">...</span>
0022   <span class="string">'DataNumPos'</span>,<span class="string">'DataNumNeg'</span>,<span class="string">'DataNumNegAcc'</span>,<span class="string">'DataNumNegPer'</span>,<span class="keyword">...</span>
0023   <span class="string">'DataNumPosStump'</span>,<span class="string">'DataJitterTran'</span>,<span class="string">'DataJitterRot'</span>};
0024 expNms=expNms(:); T = 10;
0025 [opts,lgd,lbl]=<a href="#_sub3" class="code" title="subfunction [opts,lgd,lbl] = createExp( rtDir, expNm )">createExp</a>(rtDir,expNms);
0026 
0027 <span class="comment">% run training and testing jobs</span>
0028 [jobsTrn,jobsTst] = <a href="#_sub2" class="code" title="subfunction [jobsTrn,jobsTst] = createJobs( rtDir, opts, T )">createJobs</a>( rtDir, opts, T ); N=length(expNms);
0029 fprintf(<span class="string">'nTrain = %i; nTest = %i\n'</span>,length(jobsTrn),length(jobsTst));
0030 tic, s=fevalDistr(<span class="string">'acfTrain'</span>,jobsTrn,pDistr); assert(s==1); toc
0031 tic, s=fevalDistr(<span class="string">'acfTest'</span>,jobsTst,pDistr); assert(s==1); toc
0032 
0033 <span class="comment">% create plots for all experiments</span>
0034 <span class="keyword">for</span> e=1:N, <a href="#_sub1" class="code" title="subfunction plotExps( rtDir, expNm, opts, lgd, lbl, T )">plotExps</a>(rtDir,expNms{e},opts{e},lgd{e},lbl{e},T); <span class="keyword">end</span>
0035 
0036 <span class="keyword">end</span>
0037 
0038 <a name="_sub1" href="#_subfunctions" class="code">function plotExps( rtDir, expNm, opts, lgd, lbl, T )</a>
0039 <span class="comment">% data location and parameters for plotting</span>
0040 plDir=[rtDir <span class="string">'sweeps/plots/'</span>]; <span class="keyword">if</span>(~exist(plDir,<span class="string">'dir'</span>)), mkdir(plDir); <span class="keyword">end</span>
0041 diary([plDir <span class="string">'sweeps.txt'</span>]); disp([expNm <span class="string">' ['</span> lbl <span class="string">']'</span>]); N=length(lgd);
0042 pLoad=struct(<span class="string">'squarify'</span>,{{3,.41}},<span class="string">'hRng'</span>,[0 inf]);
0043 pTest=struct(<span class="string">'name'</span>,<span class="string">''</span>, <span class="string">'imgDir'</span>,[rtDir <span class="string">'Inria/test/pos'</span>],<span class="keyword">...</span>
0044   <span class="string">'gtDir'</span>,[rtDir <span class="string">'Inria/test/posGt'</span>], <span class="string">'pLoad'</span>,pLoad);
0045 pTest=repmat(pTest,N,T); <span class="keyword">for</span> e=1:N, <span class="keyword">for</span> t=1:T,
0046     pTest(e,t).name=[opts(e).name <span class="string">'T'</span> int2str2(t,2)]; <span class="keyword">end</span>; <span class="keyword">end</span>
0047 <span class="comment">% get all miss rates and display error</span>
0048 miss=zeros(N,T); parfor e=1:N*T, miss(e)=<a href="acfTest.html" class="code" title="function [miss,roc,gt,dt] = acfTest( varargin )">acfTest</a>(pTest(e)); <span class="keyword">end</span>
0049 stds=std(miss,0,2); R=mean(miss,2); msg=<span class="string">' %.2f +/- %.2f  [%s]\n'</span>;
0050 <span class="keyword">for</span> e=1:N, fprintf(msg,R(e)*100,stds(e)*100,lgd{e}); <span class="keyword">end</span>
0051 <span class="comment">% plot sweeps</span>
0052 figPrp = {<span class="string">'Units'</span>,<span class="string">'Pixels'</span>,<span class="string">'Position'</span>,[800 600 800 400]};
0053 figure(1); clf; set(1,figPrp{:}); set(gca,<span class="string">'FontSize'</span>,24); clr=[0 .69 .94];
0054 pPl1={<span class="string">'LineWidth'</span>,3,<span class="string">'MarkerSize'</span>,15,<span class="string">'Color'</span>,clr,<span class="string">'MarkerFaceColor'</span>,clr};
0055 pPl2=pPl1; clr=[1 .75 0]; pPl2{6}=clr; pPl2{8}=clr;
0056 <span class="keyword">for</span> e=1:N, <span class="keyword">if</span>(lgd{e}(end)==<span class="string">'*'</span>), def=e; <span class="keyword">end</span>; <span class="keyword">end</span>; lgd{def}(end)=[];
0057 plot(R,<span class="string">'-d'</span>,pPl1{:}); hold on; plot(def,R(def),<span class="string">'d'</span>,pPl2{:}); e=.001;
0058 ylabel(<span class="string">'MR'</span>); axis([.5 N+.5 min([R; .15]) max([R; .3])+e]);
0059 <span class="keyword">if</span>(isempty(lbl)), imLabel(lgd,<span class="string">'bottom'</span>,30,{<span class="string">'FontSize'</span>,24}); lgd=[]; <span class="keyword">end</span>
0060 xlabel(lbl); set(gca,<span class="string">'XTick'</span>,1:N,<span class="string">'XTickLabel'</span>,lgd);
0061 <span class="comment">% save plot</span>
0062 fFig=[plDir expNm]; diary(<span class="string">'off'</span>);
0063 <span class="keyword">for</span> t=1:25, <span class="keyword">try</span> savefig(fFig,1,<span class="string">'png'</span>); <span class="keyword">break</span>; <span class="keyword">catch</span>, pause(1), <span class="keyword">end</span>; <span class="keyword">end</span>
0064 <span class="keyword">end</span>
0065 
0066 <a name="_sub2" href="#_subfunctions" class="code">function [jobsTrn,jobsTst] = createJobs( rtDir, opts, T )</a>
0067 <span class="comment">% Prepare all jobs (one train and one test job per set of opts).</span>
0068 opts=[opts{:}]; N=length(opts); NT=N*T;
0069 opts=repmat(opts,1,T); nms=cell(1,NT);
0070 jobsTrn=cell(1,NT); doneTrn=zeros(1,NT);
0071 jobsTst=cell(1,NT); doneTst=zeros(1,NT);
0072 pLoad=struct(<span class="string">'squarify'</span>,{{3,.41}},<span class="string">'hRng'</span>,[0 inf]);
0073 pTest=struct(<span class="string">'name'</span>,<span class="string">''</span>, <span class="string">'imgDir'</span>,[rtDir <span class="string">'Inria/test/pos'</span>],<span class="keyword">...</span>
0074   <span class="string">'gtDir'</span>,[rtDir <span class="string">'Inria/test/posGt'</span>], <span class="string">'pLoad'</span>,pLoad);
0075 <span class="keyword">for</span> e=1:NT
0076   t=ceil(e/N); opts(e).seed=(t-1)*100000+1;
0077   nm=[opts(e).name <span class="string">'T'</span> int2str2(t,2)];
0078   opts(e).name=nm; pTest.name=nm; nms{e}=nm;
0079   doneTrn(e)=exist([nm <span class="string">'Detector.mat'</span>],<span class="string">'file'</span>)==2; jobsTrn{e}={opts(e)};
0080   doneTst(e)=exist([nm <span class="string">'Dets.txt'</span>],<span class="string">'file'</span>)==2; jobsTst{e}={pTest};
0081 <span class="keyword">end</span>
0082 [~,kp]=unique(nms,<span class="string">'stable'</span>);
0083 doneTrn=doneTrn(kp); jobsTrn=jobsTrn(kp); jobsTrn=jobsTrn(~doneTrn);
0084 doneTst=doneTst(kp); jobsTst=jobsTst(kp); jobsTst=jobsTst(~doneTst);
0085 <span class="keyword">end</span>
0086 
0087 <a name="_sub3" href="#_subfunctions" class="code">function [opts,lgd,lbl] = createExp( rtDir, expNm )</a>
0088 
0089 <span class="comment">% if expNm is a cell, call recursively and return</span>
0090 <span class="keyword">if</span>( iscell(expNm) )
0091   N=length(expNm); opts=cell(1,N); lgd=cell(1,N); lbl=lgd;
0092   <span class="keyword">for</span> e=1:N, [opts{e},lgd{e},lbl{e}]=<a href="#_sub3" class="code" title="subfunction [opts,lgd,lbl] = createExp( rtDir, expNm )">createExp</a>(rtDir,expNm{e}); <span class="keyword">end</span>; <span class="keyword">return</span>
0093 <span class="keyword">end</span>
0094 
0095 <span class="comment">% default params for detectorTrain.m</span>
0096 dataDir=[rtDir <span class="string">'Inria/'</span>];
0097 opts=<a href="acfTrain.html" class="code" title="function detector = acfTrain( varargin )">acfTrain</a>(); opts.modelDs=[100 41]; opts.modelDsPad=[128 64];
0098 opts.posGtDir=[dataDir <span class="string">'train/posGt'</span>]; opts.nWeak=[32 128 512 2048];
0099 opts.posImgDir=[dataDir <span class="string">'train/pos'</span>]; opts.pJitter=struct(<span class="string">'flip'</span>,1);
0100 opts.negImgDir=[dataDir <span class="string">'train/neg'</span>]; opts.pBoost.pTree.fracFtrs=1/16;
0101 <span class="keyword">if</span>(~exist([rtDir <span class="string">'sweeps/res/'</span>],<span class="string">'dir'</span>)), mkdir([rtDir <span class="string">'sweeps/res/'</span>]); <span class="keyword">end</span>
0102 opts.pBoost.pTree.nThreads=1;
0103 
0104 <span class="comment">% setup experiments (N sets of params)</span>
0105 optsDefault=opts; N=100; lgd=cell(1,N); ss=lgd; lbl=<span class="string">''</span>; O=ones(1,N);
0106 pChns=opts.pPyramid.pChns(O); pPyramid=opts.pPyramid(O); opts=opts(O);
0107 <span class="keyword">switch</span> expNm
0108   <span class="keyword">case</span> <span class="string">'FtrsColorSpace'</span>
0109     N=8; clrs={<span class="string">'Gray'</span>,<span class="string">'rgb'</span>,<span class="string">'hsv'</span>,<span class="string">'luv'</span>};
0110     <span class="keyword">for</span> e=1:N, pChns(e).pColor.colorSpace=clrs{mod(e-1,4)+1}; <span class="keyword">end</span>
0111     <span class="keyword">for</span> e=5:N, pChns(e).pGradMag.enabled=0; <span class="keyword">end</span>
0112     <span class="keyword">for</span> e=5:N, pChns(e).pGradHist.enabled=0; <span class="keyword">end</span>
0113     ss=[clrs clrs]; <span class="keyword">for</span> e=1:4, ss{e}=[ss{e} <span class="string">'+G+H'</span>]; <span class="keyword">end</span>
0114     ss=upper(ss); lgd=ss;
0115   <span class="keyword">case</span> <span class="string">'FtrsChnTypes'</span>
0116     nms={<span class="string">'LUV+'</span>,<span class="string">'G+'</span>,<span class="string">'H+'</span>}; N=7;
0117     <span class="keyword">for</span> e=1:N
0118       en=false(1,3); <span class="keyword">for</span> i=1:3, en(i)=bitget(uint8(e),i); <span class="keyword">end</span>
0119       pChns(e).pColor.enabled=en(1); pChns(e).pGradMag.enabled=en(2);
0120       pChns(e).pGradHist.enabled=en(3);
0121       nm=[nms{en}]; nm=nm(1:end-1); lgd{e}=nm; ss{e}=nm;
0122     <span class="keyword">end</span>
0123   <span class="keyword">case</span> <span class="string">'FtrsGradColorChn'</span>
0124     lbl=<span class="string">'gradient color channel'</span>;
0125     N=4; ss={<span class="string">'Max'</span>,<span class="string">'L'</span>,<span class="string">'U'</span>,<span class="string">'V'</span>}; lgd=ss;
0126     <span class="keyword">for</span> e=1:N, pChns(e).pGradMag.colorChn=e-1; <span class="keyword">end</span>
0127   <span class="keyword">case</span> <span class="string">'FtrsGradNormRad'</span>
0128     lbl=<span class="string">'norm radius'</span>;
0129     vs=[0 1 2 5 10]; N=length(vs);
0130     <span class="keyword">for</span> e=1:N, pChns(e).pGradMag.normRad=vs(e); <span class="keyword">end</span>
0131   <span class="keyword">case</span> <span class="string">'FtrsGradNormConst'</span>
0132     lbl=<span class="string">'norm constant x 10^3'</span>;
0133     vs=[1 2 5 10 20 50 100]; N=length(vs);
0134     <span class="keyword">for</span> e=1:N, pChns(e).pGradMag.normConst=vs(e)/1000; <span class="keyword">end</span>
0135   <span class="keyword">case</span> <span class="string">'FtrsGradOrients'</span>
0136     lbl=<span class="string">'# orientations'</span>;
0137     vs=[2 4 6 8 10 12]; N=length(vs);
0138     <span class="keyword">for</span> e=1:N, pChns(e).pGradHist.nOrients=vs(e); <span class="keyword">end</span>
0139   <span class="keyword">case</span> <span class="string">'FtrsGradSoftBins'</span>
0140     lbl=<span class="string">'use soft bins'</span>;
0141     vs=[0 1]; N=length(vs);
0142     <span class="keyword">for</span> e=1:N, pChns(e).pGradHist.softBin=vs(e); <span class="keyword">end</span>
0143   <span class="keyword">case</span> <span class="string">'FtrsSmoothIm'</span>
0144     lbl=<span class="string">'image smooth radius'</span>;
0145     vs=[0 50 100 200]; N=length(vs);
0146     <span class="keyword">for</span> e=1:N, pChns(e).pColor.smooth=vs(e)/100; <span class="keyword">end</span>
0147     <span class="keyword">for</span> e=1:N, lgd{e}=num2str(vs(e)/100); <span class="keyword">end</span>
0148   <span class="keyword">case</span> <span class="string">'FtrsSmoothChns'</span>
0149     lbl=<span class="string">'channel smooth radius'</span>;
0150     vs=[0 50 100 200]; N=length(vs);
0151     <span class="keyword">for</span> e=1:N, pPyramid(e).smooth=vs(e)/100; <span class="keyword">end</span>
0152     <span class="keyword">for</span> e=1:N, lgd{e}=num2str(vs(e)/100); <span class="keyword">end</span>
0153   <span class="keyword">case</span> <span class="string">'FtrsShrink'</span>
0154     lbl=<span class="string">'channel shrink'</span>;
0155     vs=2.^(1:4); N=length(vs);
0156     <span class="keyword">for</span> e=1:N, pChns(e).shrink=vs(e); <span class="keyword">end</span>
0157   <span class="keyword">case</span> <span class="string">'DetModelDs'</span>
0158     lbl=<span class="string">'model height'</span>;
0159     rs=1.1.^(-2:2); vs=round(100*rs); ws=round(41*rs); N=length(vs);
0160     <span class="keyword">for</span> e=1:N, opts(e).modelDs=[vs(e) ws(e)]; <span class="keyword">end</span>
0161     <span class="keyword">for</span> e=1:N, opts(e).modelDsPad=opts(e).modelDs+[28 23]; <span class="keyword">end</span>
0162   <span class="keyword">case</span> <span class="string">'DetModelDsPad'</span>
0163     lbl=<span class="string">'padded model height'</span>;
0164     rs=1.1.^(-2:2); vs=round(128*rs); ws=round(64*rs); N=length(vs);
0165     <span class="keyword">for</span> e=1:N, opts(e).modelDsPad=[vs(e) ws(e)]; <span class="keyword">end</span>
0166   <span class="keyword">case</span> <span class="string">'DetStride'</span>
0167     lbl=<span class="string">'detector stride'</span>;
0168     vs=4:4:16; N=length(vs);
0169     <span class="keyword">for</span> e=1:N, opts(e).stride=vs(e); <span class="keyword">end</span>
0170   <span class="keyword">case</span> <span class="string">'DetNumOctaves'</span>
0171     lbl=<span class="string">'# scales per octave'</span>;
0172     vs=2.^(0:5); N=length(vs);
0173     <span class="keyword">for</span> e=1:N, pPyramid(e).nPerOct=vs(e); pPyramid(e).nApprox=vs(e)-1; <span class="keyword">end</span>
0174   <span class="keyword">case</span> <span class="string">'DetNumApprox'</span>
0175     lbl=<span class="string">'# approx scales'</span>;
0176     vs=2.^(0:5)-1; N=length(vs);
0177     <span class="keyword">for</span> e=1:N, pPyramid(e).nApprox=vs(e); <span class="keyword">end</span>
0178   <span class="keyword">case</span> <span class="string">'DetLambda'</span>
0179     lbl=<span class="string">'lambda x 100'</span>;
0180     vs=-45:15:70; N=length(vs);
0181     <span class="keyword">for</span> e=[1:4 6:N], pPyramid(e).lambdas=[0 vs(e) vs(e)]/100; <span class="keyword">end</span>
0182     <span class="keyword">for</span> e=1:N, lgd{e}=int2str(vs(e)); <span class="keyword">end</span>; vs=vs+100;
0183   <span class="keyword">case</span> <span class="string">'DetCascThr'</span>
0184     lbl=<span class="string">'cascade threshold'</span>;
0185     vs=[-.5 -1 -2 -5 -10]; N=length(vs);
0186     <span class="keyword">for</span> e=1:N, opts(e).cascThr=vs(e); <span class="keyword">end</span>
0187     <span class="keyword">for</span> e=1:N, lgd{e}=num2str(vs(e)); <span class="keyword">end</span>; vs=vs*-10;
0188   <span class="keyword">case</span> <span class="string">'DetCascCal'</span>
0189     lbl=<span class="string">'cascade offset x 10^4'</span>;
0190     vs=[5 10 20 50 100 200 500]; N=length(vs);
0191     <span class="keyword">for</span> e=1:N, opts(e).cascCal=vs(e)/1e4; <span class="keyword">end</span>
0192   <span class="keyword">case</span> <span class="string">'DetNmsThr'</span>
0193     lbl=<span class="string">'nms overlap'</span>;
0194     vs=25:10:95; N=length(vs);
0195     <span class="keyword">for</span> e=1:N, opts(e).pNms.overlap=vs(e)/1e2; <span class="keyword">end</span>
0196     <span class="keyword">for</span> e=1:N, lgd{e}=[<span class="string">'.'</span> num2str(vs(e))]; <span class="keyword">end</span>
0197   <span class="keyword">case</span> <span class="string">'TrnNumWeak'</span>
0198     lbl=<span class="string">'# decision trees / x'</span>;
0199     vs=2.^(0:3); N=length(vs);
0200     <span class="keyword">for</span> e=1:N, opts(e).nWeak=opts(e).nWeak/vs(e); <span class="keyword">end</span>
0201   <span class="keyword">case</span> <span class="string">'TrnNumBoot'</span>
0202     lbl=<span class="string">'bootstrap schedule'</span>;
0203     vs={5:1:11,5:2:11,3:1:11,3:2:11}; N=length(vs);
0204     ss={<span class="string">'5-1-11'</span>,<span class="string">'5-2-11'</span>,<span class="string">'3-1-11'</span>,<span class="string">'3-2-11'</span>}; lgd=ss;
0205     <span class="keyword">for</span> e=1:N, opts(e).nWeak=2.^vs{e}; <span class="keyword">end</span>
0206   <span class="keyword">case</span> <span class="string">'TrnDepth'</span>
0207     lbl=<span class="string">'tree depth'</span>;
0208     vs=1:5; N=length(vs);
0209     <span class="keyword">for</span> e=1:N, opts(e).pBoost.pTree.maxDepth=vs(e); <span class="keyword">end</span>
0210   <span class="keyword">case</span> <span class="string">'TrnNumBins'</span>
0211     lbl=<span class="string">'# bins'</span>;
0212     vs=2.^(4:8); N=length(vs);
0213     <span class="keyword">for</span> e=1:N, opts(e).pBoost.pTree.nBins=vs(e); <span class="keyword">end</span>
0214   <span class="keyword">case</span> <span class="string">'TrnFracFtrs'</span>
0215     lbl=<span class="string">'fraction features'</span>;
0216     vs=2.^(1:8); N=length(vs);
0217     <span class="keyword">for</span> e=1:N, opts(e).pBoost.pTree.fracFtrs=1/vs(e); <span class="keyword">end</span>
0218   <span class="keyword">case</span> <span class="string">'DataNumPos'</span>
0219     lbl=<span class="string">'# pos examples'</span>;
0220     vs=[2.^(6:9) inf]; N=length(vs);
0221     <span class="keyword">for</span> e=1:N-1, opts(e).nPos=vs(e); <span class="keyword">end</span>
0222   <span class="keyword">case</span> <span class="string">'DataNumNeg'</span>
0223     lbl=<span class="string">'# neg examples'</span>;
0224     vs=[5 10 25 50 100 250]*100; N=length(vs);
0225     <span class="keyword">for</span> e=1:N, opts(e).nNeg=vs(e); <span class="keyword">end</span>
0226   <span class="keyword">case</span> <span class="string">'DataNumNegAcc'</span>
0227     lbl=<span class="string">'# neg examples total'</span>;
0228     vs=[25 50 100 250 500]*100; N=length(vs);
0229     <span class="keyword">for</span> e=1:N, opts(e).nAccNeg=vs(e); <span class="keyword">end</span>
0230   <span class="keyword">case</span> <span class="string">'DataNumNegPer'</span>
0231     lbl=<span class="string">'# neg example / image'</span>;
0232     vs=[5 10 25 50 100]; N=length(vs);
0233     <span class="keyword">for</span> e=1:N, opts(e).nPerNeg=vs(e); <span class="keyword">end</span>
0234   <span class="keyword">case</span> <span class="string">'DataNumPosStump'</span>
0235     lbl=<span class="string">'# pos examples (stumps)'</span>;
0236     vs=[2.^(6:9) 1237 1237]; N=length(vs); lgd{N}=<span class="string">'1237*'</span>;
0237     <span class="keyword">for</span> e=1:N-1, opts(e).nPos=vs(e); opts(e).pBoost.pTree.maxDepth=1; <span class="keyword">end</span>
0238   <span class="keyword">case</span> <span class="string">'DataJitterTran'</span>
0239     lbl=<span class="string">'translational jitter'</span>;
0240     vs=[0 1 2 4]; N=length(vs); opts(1).pJitter=struct(<span class="string">'flip'</span>,1);
0241     <span class="keyword">for</span> e=2:N, opts(e).pJitter=struct(<span class="string">'flip'</span>,1,<span class="string">'nTrn'</span>,3,<span class="string">'mTrn'</span>,vs(e)); <span class="keyword">end</span>
0242     <span class="keyword">for</span> e=1:N, lgd{e}=[<span class="string">'+/-'</span> int2str(vs(e))]; <span class="keyword">end</span>
0243   <span class="keyword">case</span> <span class="string">'DataJitterRot'</span>
0244     lbl=<span class="string">'rotational jitter'</span>;
0245     vs=[0 2 4 8]; N=length(vs);
0246     <span class="keyword">for</span> e=2:N, opts(e).pJitter=struct(<span class="string">'flip'</span>,1,<span class="string">'nPhi'</span>,3,<span class="string">'mPhi'</span>,vs(e)); <span class="keyword">end</span>
0247     <span class="keyword">for</span> e=1:N, lgd{e}=[<span class="string">'+/-'</span> int2str(vs(e))]; <span class="keyword">end</span>
0248   <span class="keyword">otherwise</span>, error(<span class="string">'invalid exp: %s'</span>,expNm);
0249 <span class="keyword">end</span>
0250 
0251 <span class="comment">% produce final set of opts and find default opts</span>
0252 <span class="keyword">for</span> e=1:N, <span class="keyword">if</span>(isempty(lgd{e})), lgd{e}=int2str(vs(e)); <span class="keyword">end</span>; <span class="keyword">end</span>
0253 <span class="keyword">for</span> e=1:N, <span class="keyword">if</span>(isempty(ss{e})), ss{e}=int2str2(vs(e),5); <span class="keyword">end</span>; <span class="keyword">end</span>
0254 O=1:N; opts=opts(O); lgd=lgd(O); ss=ss(O); d=0;
0255 <span class="keyword">for</span> e=1:N, pPyramid(e).pChns=pChns(e); opts(e).pPyramid=pPyramid(e); <span class="keyword">end</span>
0256 <span class="keyword">for</span> e=1:N, <span class="keyword">if</span>(isequal(optsDefault,opts(e))), d=e; <span class="keyword">break</span>; <span class="keyword">end</span>; <span class="keyword">end</span>
0257 <span class="keyword">if</span>(d==0), disp(expNm); assert(false); <span class="keyword">end</span>
0258 <span class="keyword">for</span> e=1:N, opts(e).name=[rtDir <span class="string">'sweeps/res/'</span> expNm ss{e}]; <span class="keyword">end</span>
0259 lgd{d}=[lgd{d} <span class="string">'*'</span>]; opts(d).name=[rtDir <span class="string">'sweeps/res/Default'</span>];
0260 <span class="keyword">if</span>(0), disp([ss' lgd']'); <span class="keyword">end</span>
0261 
0262 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>